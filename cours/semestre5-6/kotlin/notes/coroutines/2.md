# 3. GÃ©rer les threads avec Dispatchers

---

[...retorn en rÃ¨ire](../../sommaire.md)

Les **coroutines** peuvent sâ€™exÃ©cuter sur **diffÃ©rents threads** grÃ¢ce aux **Dispatchers**. Contrairement aux **threads classiques**, les **Dispatchers** optimisent automatiquement l'utilisation des ressources.  

---

## **3.1. Les types de Dispatchers**  
### **ğŸ“Œ `Dispatchers.Default` â†’ Calcul intensif**  
UtilisÃ© pour **les opÃ©rations gourmandes en CPU**, comme :  
âœ… Tri et manipulation de grandes listes  
âœ… Algorithmes complexes (ex: machine learning)  

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch(Dispatchers.Default) {
        println("ExÃ©cution sur : ${Thread.currentThread().name}")
    }
}
```
âœ… Kotlin utilise **un pool de threads optimisÃ©** basÃ© sur le nombre de cÅ“urs du processeur.

---

### **ğŸŒ `Dispatchers.IO` â†’ OpÃ©rations rÃ©seau ou disque**  
IdÃ©al pour :  
âœ… **Appels rÃ©seau** (API REST)  
âœ… **Lecture/Ã©criture de fichiers**  
âœ… **RequÃªtes base de donnÃ©es**  

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch(Dispatchers.IO) {
        println("Lecture de fichier sur : ${Thread.currentThread().name}")
    }
}
```
ğŸ“Œ Contrairement Ã  `Dispatchers.Default`, ce dispatcher crÃ©e **plus de threads** si nÃ©cessaire.

---

### **ğŸ–¥ï¸ `Dispatchers.Main` â†’ UI dans Android**  
UtilisÃ© dans Android pour **mettre Ã  jour lâ€™UI sans bloquer le thread principal**.  
ğŸ’¡ **Ne fonctionne que sur Android avec `kotlinx-coroutines-android`**  

```kotlin
import kotlinx.coroutines.*

fun fetchData() {
    CoroutineScope(Dispatchers.Main).launch {
        println("Mise Ã  jour de l'UI sur : ${Thread.currentThread().name}")
    }
}
```
ğŸ“Œ **Ne jamais exÃ©cuter du code rÃ©seau sur `Dispatchers.Main`**, sinon l'UI **se figera**.

---

### **ğŸ”„ `Dispatchers.Unconfined` â†’ ExÃ©cution flexible**  
**Commence sur le thread actuel** mais peut **changer de thread** en cours dâ€™exÃ©cution.  

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch(Dispatchers.Unconfined) {
        println("DÃ©but sur : ${Thread.currentThread().name}")
        delay(1000)
        println("AprÃ¨s delay sur : ${Thread.currentThread().name}")
    }
}
```
ğŸ“Œ Ã€ utiliser **rarement** : il peut crÃ©er des comportements imprÃ©visibles.  

---

## **3.2. Changer de thread avec `withContext`**  
### **ğŸ“Œ DiffÃ©rence entre `withContext(Dispatchers.IO)` et `launch`**  

| **MÃ©thode** | **Bloque le thread ?** | **Retourne une valeur ?** | **Utilisation** |
|------------|----------------|----------------|----------------|
| `launch {}` | Non | Non | ExÃ©cuter du code sans retour |
| `async {}` | Non | Oui (`Deferred<T>`) | RÃ©cupÃ©rer une valeur asynchrone |
| `withContext {}` | Oui (temporairement) | Oui | Changer de thread et rÃ©cupÃ©rer un rÃ©sultat |

**Exemple : lecture de fichier sans bloquer lâ€™UI**  
```kotlin
import kotlinx.coroutines.*
import java.io.File

suspend fun readFile(): String {
    return withContext(Dispatchers.IO) {
        File("data.txt").readText()
    }
}

fun main() = runBlocking {
    val data = readFile()
    println(data)
}
```
âœ… `withContext(Dispatchers.IO)` permet de **changer de thread sans bloquer lâ€™exÃ©cution principale**.

---

## **3.3. Gestion des threads vs coroutines**
### **âš ï¸ Pourquoi ne pas bloquer le thread principal ?**
Bloquer le thread principal **gÃ¨le l'application** :  
âŒ Mauvais :  
```kotlin
fun main() {
    Thread.sleep(2000) // Bloque le thread principal
    println("Fin")
}
```
âœ… Bon :  
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    delay(2000) // Suspend sans bloquer le thread
    println("Fin")
}
```
ğŸ“Œ **Toujours utiliser `delay()` au lieu de `Thread.sleep()` dans une coroutine !**

---

# 4. La gestion avancÃ©e des coroutines

## **4.1. Structure hiÃ©rarchique des coroutines**
### **ğŸ“Œ Explication du `CoroutineScope`**  
Un `CoroutineScope` est un **contenant qui gÃ¨re la durÃ©e de vie des coroutines**.  

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val scope = CoroutineScope(Dispatchers.Default)

    scope.launch {
        println("Coroutine lancÃ©e")
    }
}
```

---

### **ğŸ’¡ DiffÃ©rence entre `GlobalScope`, `runBlocking`, et `CoroutineScope`**  
| **MÃ©thode** | **Blocage du thread ?** | **DurÃ©e de vie** | **Utilisation** |
|------------|----------------|----------------|----------------|
| `GlobalScope.launch` | Non | Toute la durÃ©e de l'application | âš ï¸ Ã€ Ã©viter (risque de fuite mÃ©moire) |
| `runBlocking` | Oui | Le temps d'exÃ©cution du bloc | Pour les tests |
| `CoroutineScope.launch` | Non | Se termine avec le `scope` | âœ… Bonne pratique |

---

### **ğŸ”— Lien entre les coroutines parent/enfant**
Si une coroutine parent est annulÃ©e, **toutes ses coroutines enfant sont annulÃ©es**.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val parentJob = launch {
        launch {
            delay(1000)
            println("TÃ¢che enfant terminÃ©e")
        }
    }
    
    delay(500)
    parentJob.cancel() // Annule aussi la tÃ¢che enfant
}
```

---

## **4.2. Annuler une coroutine proprement**
### **ğŸ›‘ Comment utiliser `job.cancel()` ?**
Une coroutine peut Ãªtre annulÃ©e avec `job.cancel()` mais **doit supporter l'annulation**.  

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        repeat(5) {
            delay(500)
            println("TÃ¢che en cours...")
        }
    }
    
    delay(1200)
    job.cancel() // Annule la coroutine
    println("Coroutine annulÃ©e")
}
```
ğŸ“Œ **Si une coroutine n'appelle jamais `delay()` ou `yield()`, elle ne peut pas Ãªtre annulÃ©e.**

---

### **ğŸ“Œ GÃ©rer lâ€™annulation avec `isActive`**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        while (isActive) {
            println("TÃ¢che toujours en cours...")
            delay(500)
        }
    }
    
    delay(1500)
    job.cancel()
}
```
âœ… `isActive` permet de vÃ©rifier si la coroutine **est encore en cours**.

---

### **â³ Exemple pratique : tÃ©lÃ©chargement annulable**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        repeat(100) {
            if (!isActive) return@launch
            println("TÃ©lÃ©chargement en cours... $it%")
            delay(100)
        }
    }

    delay(500)
    println("Annulation du tÃ©lÃ©chargement")
    job.cancel()
}
```
ğŸ“Œ **Si lâ€™utilisateur ferme lâ€™application, le tÃ©lÃ©chargement est annulÃ© proprement.**

---

## **4.3. Timeout et gestion du temps**
### **â° Utiliser `withTimeout()`**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    try {
        withTimeout(2000) {
            repeat(10) {
                println("TÃ¢che en cours...")
                delay(500)
            }
        }
    } catch (e: TimeoutCancellationException) {
        println("Timeout atteint !")
    }
}
```

---

### **ğŸ¤” Utiliser `withTimeoutOrNull()`**
Si le timeout est atteint, **retourne `null` au lieu dâ€™une exception**.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val result = withTimeoutOrNull(2000) {
        repeat(10) {
            println("TÃ¢che en cours...")
            delay(500)
        }
        "SuccÃ¨s"
    }

    println("RÃ©sultat : $result") // null si timeout
}
```

---

[...retorn en rÃ¨ire](../../sommaire.md)