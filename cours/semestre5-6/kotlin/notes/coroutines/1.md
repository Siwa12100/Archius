# 1. Introduction aux coroutines en Kotlin

---

[...retorn en rÃ¨ire](../../sommaire.md)

---

## **1.1. Qu'est-ce qu'une coroutine ?**  
### **ğŸ“Œ DÃ©finition et concept gÃ©nÃ©ral**  
Une **coroutine** est une maniÃ¨re **asynchrone et non bloquante** dâ€™exÃ©cuter du code. Contrairement aux **threads classiques**, elles sont beaucoup plus **lÃ©gÃ¨res** et optimisÃ©es.  

**CaractÃ©ristiques dâ€™une coroutine** :  
âœ… ExÃ©cute du code **asynchronement** sans bloquer le thread principal  
âœ… **Suspend lâ€™exÃ©cution** au lieu de bloquer le thread  
âœ… **Ã‰conomie de ressources** car plusieurs coroutines peuvent sâ€™exÃ©cuter sur un mÃªme thread  

### **ğŸ¤” DiffÃ©rence entre une coroutine et un thread**
| | **Thread** | **Coroutine** |
|----------------|----------------|----------------|
| CrÃ©ation | Lourd (consomme plus de mÃ©moire) | LÃ©ger (peut en crÃ©er des milliers sans impact) |
| Concurrence | ExÃ©cution parallÃ¨le sur plusieurs cÅ“urs | Peut Ãªtre exÃ©cutÃ© sur un seul thread |
| Blocage | Peut bloquer un thread entier | Suspend lâ€™exÃ©cution sans bloquer |
| Changement de contexte | NÃ©cessite des interruptions coÃ»teuses | Changement optimisÃ© et rapide |
| Gestion | Manuel avec `Thread` et `Runnable` | Automatique avec `CoroutineScope` |

**Exemple : Thread vs Coroutine**
```kotlin
// Utilisation des Threads classiques
fun main() {
    Thread {
        println("Thread en cours d'exÃ©cution : ${Thread.currentThread().name}")
    }.start()
}

// Utilisation des coroutines
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("Coroutine en cours d'exÃ©cution : ${Thread.currentThread().name}")
    }
}
```
**ğŸ§ RÃ©sultat** : Le thread est plus lourd alors que la coroutine est optimisÃ©e.

### **ğŸ” Pourquoi Kotlin utilise les coroutines ?**
1. Ã‰viter le **callback hell** (code imbriquÃ© et illisible)
2. RÃ©duire la **consommation mÃ©moire** en Ã©vitant de multiplier les threads
3. Faciliter la gestion des tÃ¢ches **longues** comme les appels rÃ©seau
4. Rendre le code **plus lisible** avec un style synchrone tout en Ã©tant asynchrone

---

## **1.2. Pourquoi utiliser les coroutines ?**
### **ğŸš¨ ProblÃ¨mes des threads classiques**
- Les threads consomment **beaucoup de mÃ©moire** ğŸ›‘
- Synchronisation complexe (ex: `synchronized`, `volatile`) âš ï¸
- DifficultÃ© Ã  **gÃ©rer les erreurs et exceptions**
- Bloque souvent l'UI dans une application Android  

### **ğŸ’¡ Ã‰conomie de ressources et performance**
- Une coroutine **suspend** son exÃ©cution **au lieu de bloquer un thread**
- **Des milliers de coroutines peuvent tourner sur un mÃªme thread**  
- Kotlin gÃ¨re le **changement de contexte automatiquement**  

### **ğŸ“ LisibilitÃ© et gestion simplifiÃ©e**
Regarde comment Kotlin simplifie le code asynchrone :

**Avec des Threads classiques (ğŸ˜¡ difficile Ã  lire)**
```kotlin
fun fetchData(callback: (String) -> Unit) {
    Thread {
        Thread.sleep(2000)
        callback("DonnÃ©es rÃ©cupÃ©rÃ©es")
    }.start()
}

fun main() {
    fetchData { result ->
        println(result) // Callback imbriquÃ©
    }
}
```
**Avec une coroutine (ğŸ˜ƒ plus lisible)**
```kotlin
import kotlinx.coroutines.*

suspend fun fetchData(): String {
    delay(2000) // Simule un appel rÃ©seau
    return "DonnÃ©es rÃ©cupÃ©rÃ©es"
}

fun main() = runBlocking {
    val result = fetchData()
    println(result)
}
```
ğŸ” **RÃ©sultat** : Code plus propre, sans callback ni thread bloquant.

---

## **1.3. Comment fonctionne une coroutine en interne ?**
### **ğŸ›‘ `suspend` et reprise de lâ€™exÃ©cution**
Une fonction `suspend` est une **fonction spÃ©ciale** qui peut **Ãªtre mise en pause et reprise plus tard**, sans bloquer un thread.

```kotlin
suspend fun fetchData(): String {
    delay(2000) // Suspend l'exÃ©cution sans bloquer
    return "DonnÃ©es rÃ©cupÃ©rÃ©es"
}
```
ğŸ” `delay(2000)` ne bloque pas le thread, contrairement Ã  `Thread.sleep(2000)`.

### **ğŸ”„ Explication de la pile d'exÃ©cution des coroutines**
Contrairement aux threads classiques, une coroutine **libÃ¨re le CPU lorsqu'elle attend une rÃ©ponse** :

1ï¸âƒ£ Une coroutine dÃ©marre  
2ï¸âƒ£ Elle rencontre `delay()`, donc **elle libÃ¨re le thread**  
3ï¸âƒ£ Pendant ce temps, d'autres coroutines peuvent s'exÃ©cuter  
4ï¸âƒ£ Une fois le dÃ©lai terminÃ©, **elle reprend son exÃ©cution**  

### **ğŸ¤– DiffÃ©rence avec un Thread**
| | **Thread** | **Coroutine** |
|----------------|----------------|----------------|
| Attente | Bloque le thread avec `Thread.sleep()` | Suspend sans bloquer avec `delay()` |
| Changement de contexte | CoÃ»teux en performance | OptimisÃ© par le `Scheduler` |
| Allocation mÃ©moire | 1 Mo minimum par thread | Quelques Ko par coroutine |

---

# 2. Les bases des coroutines

## **2.1. Lancer une coroutine avec `launch`**

### **ğŸ“Œ Structure de base d'une coroutine**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        println("Hello depuis une coroutine!")
    }
}
```
âœ… `runBlocking` permet d'attendre la fin des coroutines avant de quitter  
âœ… `launch` dÃ©marre une coroutine **sans bloquer** le thread principal  

### **âš ï¸ Explication du `GlobalScope`, `runBlocking` et `CoroutineScope`**
| Type | Description |
|------|------------|
| `GlobalScope.launch` | CrÃ©e une coroutine qui dure tant que l'application tourne (âš ï¸ risque de fuite mÃ©moire) |
| `runBlocking` | Bloque le thread actuel jusqu'Ã  la fin de lâ€™exÃ©cution (âš ï¸ Ã  Ã©viter en production) |
| `CoroutineScope.launch` | Meilleure pratique pour gÃ©rer le cycle de vie des coroutines |

---

## **2.2. `suspend` et son rÃ´le**
### **ğŸ¤” Pourquoi une fonction `suspend` ne peut pas Ãªtre appelÃ©e directement ?**
Une fonction `suspend` ne peut Ãªtre appelÃ©e **qu'Ã  l'intÃ©rieur dâ€™une autre coroutine** :

âŒ **Erreur :**
```kotlin
fun main() {
    fetchData() // Erreur ! Il faut une coroutine
}
```
âœ… **Solution :**
```kotlin
fun main() = runBlocking {
    val result = fetchData()
    println(result)
}
```

### **ğŸŒ Utilisation dans les appels rÃ©seau et base de donnÃ©es**
Dans une API REST, on peut utiliser `suspend` pour ne pas **bloquer lâ€™UI** :

```kotlin
import io.ktor.client.*
import io.ktor.client.request.*

val client = HttpClient()

suspend fun getUserData(): String {
    return client.get("https://api.example.com/user")
}
```

---

## **2.3. `async` et `await` pour rÃ©cupÃ©rer un rÃ©sultat**
### **ğŸš€ DiffÃ©rence entre `launch` et `async`**
| | **launch** | **async** |
|----------------|----------------|----------------|
| Retourne une valeur ? | âŒ Non | âœ… Oui (`Deferred<T>`) |
| ExÃ©cution | ExÃ©cute sans attendre de rÃ©sultat | ExÃ©cute et retourne une valeur |
| Attente | Pas besoin dâ€™attendre (`fire and forget`) | On doit utiliser `await()` |

### **ğŸ›  Utilisation de `async` pour exÃ©cuter des tÃ¢ches en parallÃ¨le**
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val task1 = async { fetchData() }
    val task2 = async { fetchData() }
    
    println("RÃ©sultats : ${task1.await()}, ${task2.await()}")
}
```
âœ… **Deux tÃ¢ches s'exÃ©cutent en mÃªme temps et on rÃ©cupÃ¨re les rÃ©sultats aprÃ¨s.**

---

[...retorn en rÃ¨ire](../../sommaire.md)