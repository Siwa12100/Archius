# **ğŸ“œ 1ï¸âƒ£ Introduction aux appels API en Kotlin (Vanilla) avec gestion asynchrone**

[...retorn en rÃ¨ire](../../sommaire.md)

---

## **1.1. PrÃ©sentation des bibliothÃ¨ques disponibles**

Kotlin permet d'effectuer des appels API de diffÃ©rentes maniÃ¨res. Voici **les trois principales options**, avec leurs avantages et inconvÃ©nients.

---

### **ğŸ”¹ 1. `java.net.HttpURLConnection` (MÃ©thode native)**
#### ğŸ“Œ **Description**
C'est **l'API standard de Java** pour effectuer des requÃªtes HTTP.  
Elle est incluse dans le JDK, donc **aucune dÃ©pendance externe** n'est requise.

#### âœ… **Avantages**
âœ” Disponible par dÃ©faut, sans dÃ©pendance  
âœ” Simple Ã  utiliser pour des cas trÃ¨s basiques  

#### âŒ **InconvÃ©nients**
â›” Beaucoup de **boilerplate** (gestion des flux manuelle)  
â›” Pas adaptÃ© aux requÃªtes asynchrones (bloque le thread)  
â›” Gestion des erreurs et parsing JSON **fastidieux**  

#### **Exemple de requÃªte GET avec `HttpURLConnection`**
```kotlin
import java.net.HttpURLConnection
import java.net.URL

fun getData() {
    val url = URL("https://api.example.com/data")
    val connection = url.openConnection() as HttpURLConnection
    connection.requestMethod = "GET"

    if (connection.responseCode == 200) {
        val response = connection.inputStream.bufferedReader().use { it.readText() }
        println("RÃ©ponse : $response")
    } else {
        println("Erreur : ${connection.responseCode}")
    }
    connection.disconnect()
}
```
ğŸ“Œ **ProblÃ¨mes** :  
- Beaucoup de code pour **une simple requÃªte**  
- Bloque le thread tant que la requÃªte nâ€™est pas terminÃ©e  

---

### **ğŸ”¹ 2. `OkHttp` (Solution populaire mais plus lourde)**
#### ğŸ“Œ **Description**
`OkHttp` est une **bibliothÃ¨que open-source dÃ©veloppÃ©e par Square**, utilisÃ©e dans **beaucoup de projets Java/Kotlin**.

#### âœ… **Avantages**
âœ” Plus simple que `HttpURLConnection`  
âœ” Supporte **les requÃªtes asynchrones**  
âœ” Gestion automatique des **timeouts** et de la mise en cache  

#### âŒ **InconvÃ©nients**
â›” NÃ©cessite **plus de code** pour la gestion des JSON  
â›” Ajoute une dÃ©pendance externe  
â›” Moins idiomatique en **Kotlin moderne**  

#### **Exemple avec OkHttp (requÃªte GET)**
```kotlin
import okhttp3.OkHttpClient
import okhttp3.Request

val client = OkHttpClient()

fun fetchData() {
    val request = Request.Builder()
        .url("https://api.example.com/data")
        .build()

    val response = client.newCall(request).execute()
    if (response.isSuccessful) {
        println("RÃ©ponse : ${response.body?.string()}")
    } else {
        println("Erreur : ${response.code}")
    }
}
```
ğŸ“Œ **ProblÃ¨mes** :
- `execute()` bloque le thread principal  
- **Besoin d'un convertisseur JSON** pour parser les donnÃ©es  

---

### **ğŸ”¹ 3. `Ktor Client` (Meilleure solution pour Kotlin)**
#### ğŸ“Œ **Description**
`Ktor Client` est une bibliothÃ¨que **dÃ©veloppÃ©e par JetBrains**, conÃ§ue **spÃ©cifiquement pour Kotlin**.  
Elle est **lÃ©gÃ¨re, idiomatique et intÃ¨gre les coroutines nativement**.

#### âœ… **Avantages**
âœ” **100% Kotlin**, conÃ§u pour **les coroutines**  
âœ” Supporte **toutes les plateformes** (JVM, JS, Native)  
âœ” SÃ©rialisation/dÃ©sÃ©rialisation **intÃ©grÃ©e** (`kotlinx.serialization`)  
âœ” **Facile Ã  configurer** et extensible  

#### âŒ **InconvÃ©nients**
â›” **NÃ©cessite une configuration initiale**  
â›” **Peu connu** en dehors de l'Ã©cosystÃ¨me Kotlin  

#### **Exemple avec `Ktor Client`**
```kotlin
import io.ktor.client.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.*

val client = HttpClient()

suspend fun fetchData(): String {
    return client.get("https://api.example.com/data").bodyAsText()
}

fun main() = runBlocking {
    val result = fetchData()
    println(result)
}
```
ğŸ“Œ **Avantages** :
- Moins de **boilerplate**  
- ComplÃ¨tement **asynchrone et non bloquant**  
- **JSON parsing intÃ©grÃ©** avec `kotlinx.serialization`  

---

### **ğŸ’¡ Pourquoi choisir `Ktor Client` ?**
| | `HttpURLConnection` | `OkHttp` | **`Ktor Client`** |
|----------------|----------------|----------------|----------------|
| FacilitÃ© dâ€™utilisation | âŒ CompliquÃ© | âœ… Moyen | âœ…âœ… TrÃ¨s simple |
| Support asynchrone | âŒ Non | âœ… Oui | âœ…âœ… Oui (coroutines) |
| SÃ©rialisation JSON | âŒ Manuelle | âŒ Manuelle | âœ… IntÃ©grÃ©e |
| Performance | âŒ Bloque le thread | âœ… Bon | âœ…âœ… Excellente |
| ModularitÃ© | âŒ Rigide | âœ… Moyen | âœ…âœ… TrÃ¨s flexible |

**ğŸš€ Conclusion** : `Ktor Client` est **le choix recommandÃ©** pour Kotlin moderne.  

---

## **1.2. Configuration de `Ktor Client` avec Maven**
### **ğŸ“Œ Ajout des dÃ©pendances dans `pom.xml`**
Ajoute ces dÃ©pendances dans ton fichier **`pom.xml`** :

```xml
<dependencies>
    <!-- Ktor Core (Obligatoire) -->
    <dependency>
        <groupId>io.ktor</groupId>
        <artifactId>ktor-client-core</artifactId>
        <version>2.3.0</version>
    </dependency>

    <!-- ImplÃ©mentation avec CIO (RecommandÃ©) -->
    <dependency>
        <groupId>io.ktor</groupId>
        <artifactId>ktor-client-cio</artifactId>
        <version>2.3.0</version>
    </dependency>

    <!-- Gestion automatique des JSON -->
    <dependency>
        <groupId>io.ktor</groupId>
        <artifactId>ktor-client-content-negotiation</artifactId>
        <version>2.3.0</version>
    </dependency>

    <!-- SÃ©rialisation avec kotlinx.serialization -->
    <dependency>
        <groupId>io.ktor</groupId>
        <artifactId>ktor-serialization-kotlinx-json</artifactId>
        <version>2.3.0</version>
    </dependency>
</dependencies>
```
ğŸ“Œ **Explication des modules** :
- `ktor-client-core` â†’ Module **obligatoire** (contient les bases du client HTTP)
- `ktor-client-cio` â†’ ImplÃ©mentation **asynchrone et performante**
- `ktor-client-content-negotiation` â†’ Ajoute la **gestion automatique du JSON**
- `ktor-serialization-kotlinx-json` â†’ **DÃ©sÃ©rialisation JSON native en Kotlin**

---

### **ğŸ“Œ Configuration dâ€™un `HttpClient` de base**
Une fois les dÃ©pendances installÃ©es, tu peux **crÃ©er un client Ktor** et **faire un premier appel API**.

#### **1ï¸âƒ£ CrÃ©ation du client**
```kotlin
import io.ktor.client.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.engine.cio.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.serialization.json.Json

val client = HttpClient(CIO) {
    install(ContentNegotiation) {
        json(Json { ignoreUnknownKeys = true }) // Ignore les champs inconnus
    }
}
```
ğŸ“Œ **Pourquoi `CIO` ?**  
- **Rapide et non bloquant**
- GÃ¨re automatiquement **les connexions simultanÃ©es**
- Supporte **les websockets et HTTP2**

---

#### **2ï¸âƒ£ PremiÃ¨re requÃªte GET avec `Ktor Client`**
```kotlin
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.*

suspend fun fetchData(): String {
    return client.get("https://api.example.com/data").bodyAsText()
}

fun main() = runBlocking {
    println(fetchData())
}
```
âœ… **ExÃ©cution 100% asynchrone et optimisÃ©e**  
âœ… **Gestion JSON native**  

---

[...retorn en rÃ¨ire](../../sommaire.md)