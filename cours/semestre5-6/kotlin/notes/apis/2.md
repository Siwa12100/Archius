# 2. Appels API asynchrones avec Ktor Client

[...retorn en rÃ¨ire](../../sommaire.md)

---

Ktor Client est une bibliothÃ¨que lÃ©gÃ¨re et asynchrone permettant d'effectuer des requÃªtes HTTP en Kotlin. Il s'intÃ¨gre bien avec `kotlinx.serialization` pour gÃ©rer facilement les donnÃ©es au format JSON.

---

## 2.1. Effectuer des requÃªtes GET, POST, PUT, DELETE

### ğŸ“Œ Explication des verbes HTTP
- **GET** : RÃ©cupÃ¨re des donnÃ©es depuis un serveur.
- **POST** : Envoie des donnÃ©es au serveur pour crÃ©er une ressource.
- **PUT** : Met Ã  jour une ressource existante.
- **DELETE** : Supprime une ressource sur le serveur.

### ğŸ”¹ RÃ©cupÃ©rer des donnÃ©es avec GET
```kotlin
val client = HttpClient()

suspend fun fetchData(): String {
    return client.get("https://api.example.com/data")
}
```

### ğŸ”¹ Envoyer des donnÃ©es avec POST
```kotlin
data class User(val name: String, val age: Int)

suspend fun createUser(user: User): String {
    return client.post("https://api.example.com/users") {
        contentType(ContentType.Application.Json)
        setBody(user)
    }
}
```

### ğŸ”¹ Mettre Ã  jour avec PUT
```kotlin
suspend fun updateUser(userId: Int, user: User): String {
    return client.put("https://api.example.com/users/$userId") {
        contentType(ContentType.Application.Json)
        setBody(user)
    }
}
```

### ğŸ”¹ Supprimer avec DELETE
```kotlin
suspend fun deleteUser(userId: Int): String {
    return client.delete("https://api.example.com/users/$userId")
}
```

### ğŸ“Œ Gestion des headers et paramÃ¨tres dâ€™URL
```kotlin
suspend fun fetchWithHeaders(): String {
    return client.get("https://api.example.com/data") {
        headers {
            append("Authorization", "Bearer token")
            append("Accept", "application/json")
        }
        parameter("page", 1)
        parameter("limit", 10)
    }
}
```

---

## 2.2. SÃ©rialisation et dÃ©sÃ©rialisation automatique

Ktor Client fonctionne avec `kotlinx.serialization` pour convertir les objets Kotlin en JSON et inversement.

### ğŸ”¹ Utilisation de kotlinx.serialization
Ajoutez la dÃ©pendance :
```kotlin
implementation("io.ktor:ktor-client-content-negotiation:latest-version")
implementation("io.ktor:ktor-serialization-kotlinx-json:latest-version")
```

### ğŸ”¹ SÃ©rialiser des objets en JSON (`setBody`)
```kotlin
val client = HttpClient {
    install(ContentNegotiation) {
        json()
    }
}

suspend fun createUser(user: User): String {
    return client.post("https://api.example.com/users") {
        contentType(ContentType.Application.Json)
        setBody(user)
    }
}
```

### ğŸ”¹ DÃ©sÃ©rialiser une rÃ©ponse JSON (`body<T>()`)
```kotlin
@Serializable
data class ApiResponse(val success: Boolean, val message: String)

suspend fun fetchResponse(): ApiResponse {
    return client.get("https://api.example.com/status").body()
}
```

### ğŸ”¹ GÃ©rer des erreurs de parsing
```kotlin
suspend fun safeFetchResponse(): ApiResponse? {
    return try {
        client.get("https://api.example.com/status").body<ApiResponse>()
    } catch (e: SerializationException) {
        println("Erreur de parsing JSON : ${e.message}")
        null
    }
}
```

---

## 2.3. Gestion des erreurs et des exceptions

### ğŸ”¹ try/catch et `response.status`
```kotlin
suspend fun fetchWithHandling(): String {
    return try {
        val response = client.get("https://api.example.com/data")
        if (response.status == HttpStatusCode.OK) {
            response.body()
        } else {
            "Erreur: ${response.status}"
        }
    } catch (e: Exception) {
        "Exception: ${e.message}"
    }
}
```

### ğŸ”¹ VÃ©rifier les erreurs HTTP (404, 500, 401â€¦)
```kotlin
suspend fun fetchWithErrorHandling(): String {
    return client.get("https://api.example.com/data").let { response ->
        when (response.status) {
            HttpStatusCode.OK -> response.body()
            HttpStatusCode.NotFound -> "Erreur 404 : Ressource non trouvÃ©e"
            HttpStatusCode.Unauthorized -> "Erreur 401 : AccÃ¨s refusÃ©"
            else -> "Erreur: ${response.status}"
        }
    }
}
```

### ğŸ”¹ Utilisation des `expect` blocks pour gÃ©rer les rÃ©ponses invalides
```kotlin
suspend fun fetchExpectingJson(): String {
    return try {
        client.get("https://api.example.com/data").body<ApiResponse>().message
    } catch (e: ClientRequestException) {
        "RequÃªte invalide : ${e.response.status}"
    } catch (e: ServerResponseException) {
        "Erreur serveur : ${e.response.status}"
    } catch (e: Exception) {
        "Autre erreur : ${e.message}"
    }
}
```

### ğŸ”¹ Mise en place dâ€™un interceptor global pour logger les erreurs
```kotlin
val client = HttpClient {
    install(ResponseObserver) {
        onResponse { response ->
            if (!response.status.isSuccess()) {
                println("âš ï¸ Erreur HTTP: ${response.status}")
            }
        }
    }
}
```

---

[...retorn en rÃ¨ire](../../sommaire.md)
