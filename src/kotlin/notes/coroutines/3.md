# 5. SÃ©quence et flux de donnÃ©es asynchrones en Kotlin**

[...retorn en rÃ¨ire](../../sommaire.md)

Dans Kotlin, lorsquâ€™on travaille avec des **donnÃ©es en continu** (comme des Ã©vÃ©nements, des mises Ã  jour en temps rÃ©el, des requÃªtes rÃ©seau rÃ©currentes), il est prÃ©fÃ©rable dâ€™utiliser **Flow** plutÃ´t que `suspend fun`. Cette section couvre en dÃ©tail les **flux asynchrones avec `Flow`**, ainsi que `StateFlow` et `SharedFlow` pour la gestion avancÃ©e dâ€™Ã©tat et dâ€™Ã©vÃ©nements.

---

## **5.1. Introduction Ã  `Flow`**
### **ğŸ“Œ Pourquoi `Flow` remplace `LiveData` ou `RxJava` ?**
Avant lâ€™arrivÃ©e de `Flow`, plusieurs solutions Ã©taient utilisÃ©es pour gÃ©rer des flux de donnÃ©es asynchrones :
- **RxJava** : Puissant mais lourd et complexe
- **LiveData** : Bien pour Android, mais limitÃ© (cycle de vie UI uniquement)
- **Channels** : Bonne alternative, mais peu intuitive pour les valeurs multiples

âœ… **`Flow` a plusieurs avantages :**
- Il est **lÃ©ger et nativement supportÃ© par Kotlin**  
- Il respecte le **paradigme des coroutines**  
- Il est **plus simple que RxJava**, sans surcharge  

---

### **ğŸ“Œ DiffÃ©rence entre `Flow` et `suspend fun`**
| | **`suspend fun`** | **`Flow`** |
|----------------|----------------|----------------|
| Nombre de valeurs retournÃ©es | **1 seule valeur** | **Plusieurs valeurs sur le temps** |
| Type de retour | `T` | `Flow<T>` |
| Utilisation | **Appel unique** | **Flux continu de donnÃ©es** |
| Mode d'exÃ©cution | Bloquant jusqu'Ã  la fin | Ã‰mission de valeurs **de maniÃ¨re asynchrone** |

**Exemple comparatif** :
```kotlin
// suspend fun : retourne une seule valeur
suspend fun fetchData(): String {
    delay(1000)
    return "DonnÃ©e rÃ©cupÃ©rÃ©e"
}

// Flow : retourne plusieurs valeurs au fil du temps
fun fetchDataFlow(): Flow<String> = flow {
    emit("Chargement...")
    delay(1000)
    emit("DonnÃ©e rÃ©cupÃ©rÃ©e")
}
```

---

### **ğŸ“Œ Utilisation basique de `Flow`**
1. **CrÃ©ation dâ€™un `Flow`**  
2. **Emission des valeurs avec `emit()`**  
3. **Collecte des valeurs avec `collect()`**  

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun fetchData(): Flow<Int> = flow {
    for (i in 1..5) {
        delay(1000)
        emit(i)
    }
}

fun main() = runBlocking {
    fetchData().collect { value ->
        println("ReÃ§u : $value")
    }
}
```
âœ… `emit()` envoie une valeur, `collect()` la reÃ§oit en temps rÃ©el.  

---

## **5.2. Manipulation avancÃ©e de `Flow`**
### **ğŸ“Œ `map`, `filter`, `collect`**
Comme les collections Kotlin (`List`, `Sequence`), `Flow` permet dâ€™appliquer des transformations.

```kotlin
fun fetchData(): Flow<Int> = flow {
    for (i in 1..5) {
        delay(500)
        emit(i)
    }
}

fun main() = runBlocking {
    fetchData()
        .filter { it % 2 == 0 } // Ne prend que les nombres pairs
        .map { "Valeur transformÃ©e : $it" }
        .collect { println(it) }
}
```
âœ… **RÃ©sultat attendu** :  
```
Valeur transformÃ©e : 2  
Valeur transformÃ©e : 4  
```

---

### **ğŸ“Œ `flatMapConcat`, `flatMapMerge` : Transformer un `Flow` en un autre `Flow`**
#### **ğŸŸ¢ `flatMapConcat()` : ExÃ©cute chaque sous-flux **sÃ©quentiellement**
```kotlin
fun fetchData(id: Int): Flow<String> = flow {
    emit("Chargement de l'id $id")
    delay(500)
    emit("DonnÃ©e $id prÃªte")
}

fun main() = runBlocking {
    (1..3).asFlow()
        .flatMapConcat { fetchData(it) }
        .collect { println(it) }
}
```
**Sortie :**
```
Chargement de l'id 1
DonnÃ©e 1 prÃªte
Chargement de l'id 2
DonnÃ©e 2 prÃªte
Chargement de l'id 3
DonnÃ©e 3 prÃªte
```
âœ… **Traitement sÃ©quentiel** : Chaque ID est traitÃ© **lâ€™un aprÃ¨s lâ€™autre**.

---

#### **ğŸŸ  `flatMapMerge()` : ExÃ©cute tous les flux en parallÃ¨le**
```kotlin
fun main() = runBlocking {
    (1..3).asFlow()
        .flatMapMerge { fetchData(it) }
        .collect { println(it) }
}
```
**Sortie (dÃ©sordonnÃ©e car parallÃ¨le) :**
```
Chargement de l'id 1
Chargement de l'id 2
Chargement de l'id 3
DonnÃ©e 1 prÃªte
DonnÃ©e 2 prÃªte
DonnÃ©e 3 prÃªte
```
âœ… **Gagne en performance** car **exÃ©cution en parallÃ¨le**.

---

### **ğŸ“Œ Gestion des erreurs dans `Flow`**
Comme pour les coroutines, on peut **gÃ©rer les erreurs avec `catch {}`** :

```kotlin
fun fetchData(): Flow<Int> = flow {
    for (i in 1..3) {
        if (i == 2) throw RuntimeException("Erreur sur $i")
        emit(i)
    }
}.catch { e ->
    println("Erreur capturÃ©e : ${e.message}")
}

fun main() = runBlocking {
    fetchData().collect { println(it) }
}
```
âœ… `catch {}` **intercepte lâ€™exception et empÃªche le crash**.

---

## **5.3. `StateFlow` et `SharedFlow`**
### **ğŸ“Œ DiffÃ©rence entre `Flow`, `StateFlow`, et `SharedFlow`**
| | **Flow** | **StateFlow** | **SharedFlow** |
|----------------|----------------|----------------|----------------|
| Type de donnÃ©es | **Flux simple** | **Stocke la derniÃ¨re valeur** | **Diffuse des Ã©vÃ©nements** |
| Valeur par dÃ©faut | âŒ Non | âœ… Oui (dernier Ã©tat) | âŒ Non |
| Rejoue les valeurs ? | âŒ Non | âœ… Toujours la derniÃ¨re valeur | âœ… Peut rejouer `n` valeurs |
| Utilisation typique | **RÃ©cupÃ©ration de donnÃ©es** | **Ã‰tat dâ€™une UI (ex: ViewModel)** | **Ã‰vÃ©nements (ex: notifications)** |

---

### **ğŸ“Œ `StateFlow` : Gestion dâ€™un Ã©tat en continu**
UtilisÃ© pour **gÃ©rer un Ã©tat dynamique** qui change au fil du temps (ex: Ã©tat dâ€™un Ã©cran UI).

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.random.Random

class ViewModel {
    private val _state = MutableStateFlow(0) // Valeur initiale
    val state: StateFlow<Int> = _state

    suspend fun increment() {
        _state.emit(Random.nextInt(1, 100))
    }
}

fun main() = runBlocking {
    val viewModel = ViewModel()

    launch {
        viewModel.state.collect { println("Nouvelle valeur : $it") }
    }

    delay(1000)
    viewModel.increment()
    delay(1000)
}
```
âœ… **Toujours la derniÃ¨re valeur** et **pas de perte dâ€™informations**.

---

### **ğŸ“Œ `SharedFlow` : Ã‰mettre des Ã©vÃ©nements pour plusieurs consommateurs**
UtilisÃ© pour **gÃ©rer des Ã©vÃ©nements**, comme des **notifications push**.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

class EventBus {
    private val _events = MutableSharedFlow<String>(replay = 2)
    val events: SharedFlow<String> = _events

    suspend fun sendEvent(event: String) {
        _events.emit(event)
    }
}

fun main() = runBlocking {
    val eventBus = EventBus()

    launch {
        eventBus.events.collect { println("ReÃ§u : $it") }
    }

    eventBus.sendEvent("Nouvelle notification")
}
```
âœ… **Tous les abonnÃ©s reÃ§oivent les Ã©vÃ©nements envoyÃ©s aprÃ¨s leur connexion**.

---

[...retorn en rÃ¨ire](../../sommaire.md)