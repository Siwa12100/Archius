# Cours “manipulation propre de la STL” – Ajout, modif, suppression, doublons, parcours

[...retorn en rèire](../menu.md)

---

> Objectif : avoir des **patrons de code tout faits** pour gérer `vector`, `list`, `map`, `set`, `unordered_*` en DS :
> - ajout propre,
> - modification,
> - suppression (y compris en plein parcours),
> - gestion des doublons,
> - parcours avant / arrière,
> - utilisation correcte des itérateurs.

Je vais te donner des **recettes prêtes à recoller** dans ta copie, avec commentaires.

---

## 0. Règles de style générales

- **Passer les gros conteneurs par référence `const`** en lecture :

```cpp
void print(const std::vector<int> &v);
```

- **Utiliser `auto` pour les itérateurs** :

```cpp
for (auto it = v.begin(); it != v.end(); ++it) { /* ... */ }
```

- **Préférer les boucles `for` “range-based”** quand tu ne modifies pas la structure :

```cpp
for (int x : v) { /* lecture */ }

for (auto &x : v) { /* lecture/écriture sur x */ }
```

---

## 1. Ajout d’éléments

### 1.1. Séquences (`vector`, `deque`, `list`)

#### À la fin

```cpp
std::vector<int> v;

// Ajout simple
v.push_back(42);         // copie ou move de 42
v.emplace_back(42);      // construit 42 directement sur place
```

Pour un type perso :

```cpp
struct Point { int x, y; };

std::vector<Point> vp;
vp.emplace_back(1, 2);   // construit Point{1,2} directement
```

#### Au début (et partout pour `list`)

```cpp
std::list<int> l;
l.push_front(1);         // début
l.push_back(2);          // fin

auto it = l.begin();     // insertion avant it
l.insert(it, 100);       // O(1) pour list
```

Pour `vector` :

```cpp
std::vector<int> v = {1,2,3};
auto it = v.begin() + 1;
v.insert(it, 100);       // O(n) (décalages)
```

#### Insérer une plage d’éléments

```cpp
std::vector<int> a = {1,2,3};
std::vector<int> b = {10,20};

a.insert(a.end(), b.begin(), b.end()); // a = {1,2,3,10,20}
```

---

### 1.2. Associatifs (`set`, `map`, `unordered_*`)

```cpp
std::set<int> s;
s.insert(3);
s.insert(1);
s.insert(3);   // ne fait rien : pas de doublon en set
```

Pour `map` :

```cpp
std::map<std::string, int> m;

// insert
m.insert(std::make_pair("Alice", 10));
m.insert({"Bob", 20});

// accès/ajout via operator[]
m["Charlie"] = 30;  // insère "Charlie" si absent
```

Pour `unordered_map` idem, juste sans tri.

---

## 2. Modification des éléments

### 2.1. Séquences

Avec index (`vector`, `deque`, `array`, `string`) :

```cpp
for (std::size_t i = 0; i < v.size(); ++i) {
    v[i] *= 2;
}
```

Avec références (tous les conteneurs séquentiels) :

```cpp
for (auto &x : v) {
    x *= 2;
}
```

### 2.2. `map` / `unordered_map`

Accès par clé :

```cpp
m["Alice"] += 5;  // modifie la valeur associée à "Alice"
// attention : crée la clé si absente
```

Via l’itérateur :

```cpp
for (auto &p : m) {
    // p est un std::pair<const Key, T>
    std::cout << p.first << " => " << p.second << '\n';
    p.second *= 2; // OK
    // p.first = nouvelle clé; // IMPOSSIBLE : clé const
}
```

---

## 3. Suppression d’éléments

### 3.1. Suppression simple (sans boucler en même temps)

#### Séquences

```cpp
std::vector<int> v = {1,2,3,4};

// enlever le 3e élément (index 2)
v.erase(v.begin() + 2);

// vider
v.clear();
```

`list` :

```cpp
std::list<int> l = {1,2,3,4};
auto it = l.begin();
++it;               // pointe sur 2
l.erase(it);        // O(1)
```

#### Associatifs

```cpp
std::set<int> s = {1,2,3};
s.erase(2);               // supprime la clé 2 (si présente)

std::map<std::string,int> m;
m["Alice"] = 1;
m["Bob"]   = 2;

m.erase("Alice");         // par clé

auto it = m.find("Bob");
if (it != m.end()) {
    m.erase(it);         // par itérateur
}
```

---

### 3.2. “Je veux supprimer selon une condition en PARCOURANT”

Patron *canonique* pour DS.

#### 3.2.1. `vector` / `deque` / `string` : **erase-remove idiom**

> “Supprimer tous les éléments égaux à 0” :

```cpp
std::vector<int> v = {1,0,2,0,3};

v.erase(
    std::remove(v.begin(), v.end(), 0),
    v.end()
);
```

> “Supprimer tous les éléments qui vérifient un prédicat” :

```cpp
v.erase(
    std::remove_if(v.begin(), v.end(),
        [](int x) { return x % 2 == 0; } // supprime pairs
    ),
    v.end()
);
```

À recracher tel quel si le DS parle de suppression par condition dans un `vector`.

#### 3.2.2. `list` : `remove` / `remove_if` membres

```cpp
std::list<int> l = {1,0,2,0,3};

l.remove(0); // supprime tous les 0

l.remove_if([](int x) { return x % 2 == 0; }); // supprime les pairs
```

#### 3.2.3. Patron générique “while(it != end())” (marche pour tous)

Pour tous les conteneurs qui ont `erase(it)` qui renvoie l’itérateur suivant :
- `list`
- `forward_list`
- `map`, `set`, `unordered_*`  
(Pour `vector`, ça marche aussi, mais c’est moins joli que erase-remove).

```cpp
for (auto it = c.begin(); it != c.end(); ) {
    if (condition(*it)) {
        it = c.erase(it);   // reçoit l’itérateur sur le suivant
    } else {
        ++it;
    }
}
```

Exemple avec `map` :

```cpp
std::map<std::string, int> m;
// supprimer toutes les entrées avec valeur 0
for (auto it = m.begin(); it != m.end(); ) {
    if (it->second == 0) {
        it = m.erase(it);
    } else {
        ++it;
    }
}
```

**À connaître par cœur** → c’est LA recette “suppression pendant parcours”.

---

## 4. Gestion des doublons

### 4.1. Avec `set` / `unordered_set` (auto-gestion)

Par définition, **pas de doublons** :

```cpp
std::set<int> s;
auto res = s.insert(3);
if (!res.second) {
    // 3 était déjà présent
}
```

Le `insert` renvoie `std::pair<iterator, bool>` :
- `second == true` → insertion faite,
- `second == false` → déjà présent.

---

### 4.2. Avec `map` / `unordered_map`

Doublons de clés interdits. Avec `insert` :

```cpp
std::map<std::string,int> m;

auto res = m.insert({"Alice", 10});
if (!res.second) {
    // "Alice" était déjà là : résout le conflit comme tu veux
    // par ex : mettre à jour la valeur
    res.first->second += 10;
}
```

---

### 4.3. Avec `vector` (tri + `unique`)

> “Enlever les doublons d’un vector” (ordre sans importance) :

```cpp
std::vector<int> v = {3,1,2,3,2,1};

std::sort(v.begin(), v.end());     // {1,1,2,2,3,3}
v.erase(
    std::unique(v.begin(), v.end()),
    v.end()
);
// v = {1,2,3}
```

> “Conserver un seul exemplaire de chaque élément” : **tri + unique + erase**.

---

## 5. Parcours avant / arrière

### 5.1. Avant (tous les conteneurs)

Boucle range-based lecture :

```cpp
for (int x : v) {
    std::cout << x << '\n';
}
```

Lecture/écriture :

```cpp
for (auto &x : v) {
    x *= 2;
}
```

Avec itérateur :

```cpp
for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}
```

### 5.2. Arrière (ceux qui ont des reverse iterators : `vector`, `deque`, `list`, `map`, `set`, `string`…)

```cpp
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    std::cout << *it << '\n';
}
```

Sur `map` (du plus grand au plus petit) :

```cpp
for (auto it = m.rbegin(); it != m.rend(); ++it) {
    std::cout << it->first << " => " << it->second << '\n';
}
```

---

## 6. Itérateurs : patterns propres

### 6.1. Lecture seule avec const_iterator

```cpp
void print(const std::vector<int> &v) {
    for (auto it = v.cbegin(); it != v.cend(); ++it) {
        std::cout << *it << '\n';
    }
}
```

### 6.2. Modification via itérateur

```cpp
for (auto it = v.begin(); it != v.end(); ++it) {
    *it *= 2;
}
```

### 6.3. Recherche

- Séquences :

```cpp
auto it = std::find(v.begin(), v.end(), 42);
if (it != v.end()) {
    // trouvé
}
```

- Associatifs (préférer `find` membre) :

```cpp
auto it = m.find("Alice");
if (it != m.end()) {
    std::cout << it->second;
}
```

---

## 7. Mini-fiche DS : patrons à recracher

### 7.1. Supprimer tous les éléments vérifiant une condition dans un `vector<int>`

```cpp
v.erase(
    std::remove_if(v.begin(), v.end(),
        [](int x) { return /* condition(x) */; }
    ),
    v.end()
);
```

### 7.2. Supprimer pendant un parcours (`list`, `map`, `set`, `unordered_*`)

```cpp
for (auto it = c.begin(); it != c.end(); ) {
    if (/* condition sur *it ou it->second */) {
        it = c.erase(it);
    } else {
        ++it;
    }
}
```

### 7.3. Lire une `map` proprement

```cpp
for (const auto &p : m) {
    std::cout << p.first << " => " << p.second << '\n';
}
```

### 7.4. Gestion de doublons de clés en `map`

```cpp
auto res = m.insert({key, value});
if (!res.second) {
    // déjà présent : on choisit ce qu'on fait
    res.first->second = /* nouvelle valeur */;
}
```

### 7.5. Supprimer les doublons d’un `vector` (ordre non important)

```cpp
std::sort(v.begin(), v.end());
v.erase(std::unique(v.begin(), v.end()), v.end());
```

### 7.6. Parcours arrière d’un `vector`

```cpp
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    std::cout << *it << '\n';
}
```

---

[...retorn en rèire](../menu.md)