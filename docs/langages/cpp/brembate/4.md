# Cours STL – `vector`, `list`, `map`, `set`, itérateurs, complexité 

[...retorn en rèire](../menu.md)

---

> Objectif :  
> - Savoir **quel conteneur choisir** et **pourquoi** (complexité, propriétés).  
> - Comprendre les syntaxes (itérateurs, `begin()`, `end()`, `insert()`, `erase()`, etc.).  
> - Connaître les **règles d’invalidation d’itérateurs / références**.  
> - Être prêt aux **questions tordues de DS**.

Je vais structurer en :

1. Vue d’ensemble de la STL : familles de conteneurs  
2. Conteneurs de séquence : `vector`, `deque`, `list` (+ `string`, `array` en bonus)  
3. Conteneurs associatifs ordonnés : `set`, `map`, `multiset`, `multimap`  
4. Conteneurs associatifs non ordonnés : `unordered_set`, `unordered_map`…  
5. Adaptateurs de conteneurs : `stack`, `queue`, `priority_queue`  
6. Itérateurs : syntaxe, catégories, pièges  
7. Choisir le bon conteneur (tableau décisionnel + cas typiques)  
8. Pièges classiques de DS (questions de prof)

---

## 1. Vue d’ensemble : les grandes familles de conteneurs

### 1.1. Familles principales

1. **Conteneurs de séquence** (éléments dans un ordre linéaire)
   - `std::vector`
   - `std::deque`
   - `std::list`
   - `std::forward_list`
   - `std::array`
   - `std::string` (techniquement séquence de `char`)

2. **Conteneurs associatifs ordonnés** (arbres équilibrés, triés par clé)
   - `std::set`, `std::multiset`
   - `std::map`, `std::multimap`

3. **Conteneurs associatifs non ordonnés** (hash tables)
   - `std::unordered_set`, `std::unordered_multiset`
   - `std::unordered_map`, `std::unordered_multimap`

4. **Adaptateurs** (enrobent un autre conteneur)
   - `std::stack`
   - `std::queue`
   - `std::priority_queue`

---

### 1.2. Interface commune de base

La plupart des conteneurs ont :

- Types :
  - `value_type`, `iterator`, `const_iterator`, `size_type`…
- Méthodes :
  - `size()`, `empty()`, `begin()`, `end()`, `cbegin()`, `cend()`
  - `insert(...)`, `erase(...)`, `clear()`, `find(...)` (pour les associatifs)
- Sémantique **de valeur** :
  - Quand tu fais `v2 = v1;`, tu **copies toutes les valeurs**, pas de référence partagée automatique.

---

## 2. Conteneurs de séquence

### 2.1. `std::vector` – le couteau suisse

#### 2.1.1. Idée

- Tableau dynamique contigu :
  - Les éléments sont en mémoire l’un à côté de l’autre (comme un `T[]`),
  - Taille variable (`push_back`, `resize`, `insert`, `erase`),
  - Accès aléatoire en `O(1)` : `v[i]`.

#### 2.1.2. Complexité (cas moyen / amortie)

- Accès `v[i]` / `v.at(i)` → **O(1)**.
- `push_back()` :
  - **amorti O(1)** (réalloue de temps en temps).
- Insertion/suppression à la **fin** → O(1) amorti.
- Insertion/suppression au **milieu / début** :
  - Il faut **décaler** tous les éléments après → **O(n)**.

#### 2.1.3. Invalidations (piège de DS)

- Quand une réallocation a lieu (taille > capacité) :
  - Tous les **itérateurs, pointeurs, références** vers des éléments sont **invalidés**.
- Quand tu insères/effaces au milieu :
  - Itérateurs/réfs **à partir de cet élément** peuvent devenir invalides (même sans réallocation).

Exemple :

```cpp
std::vector<int> v = {1,2,3};
int &r = v[0];
v.push_back(4);   // peut réallouer → r devient potentiellement invalide
```

---

#### 2.1.4. Syntaxe fréquente

```cpp
std::vector<int> v;              // vide
std::vector<int> v2(10);         // 10 int initialisés à 0
std::vector<int> v3(10, 42);     // 10 int à 42
std::vector<int> v4 = {1,2,3};   // liste d'initialisation

v.push_back(5);
v.pop_back();

for (std::size_t i = 0; i < v.size(); ++i) {
    std::cout << v[i] << '\n';
}

for (int x : v) {   // range-based for
    std::cout << x << '\n';
}

// Itérateurs
for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}
```

---

### 2.2. `std::deque` – double-ended queue

#### 2.2.1. Idée

- Mémoire **non contiguë**, mais :
  - accès `operator[]` en **O(1)**,
  - **insertion/suppression rapide au début ET à la fin**.

Comparé à `vector` :

- `vector` : optimisé pour le **back** (`push_back`).
- `deque` : optimisé pour **front et back** (`push_back`, `push_front`).

#### 2.2.2. Complexité

- Accès `[i]` → **O(1)**.
- `push_back`, `push_front` → amorti **O(1)**.
- Insertion/suppression au milieu → **O(n)** (comme `vector`).

#### 2.2.3. Piège

- Mémoire non contiguë → attention si tu passes `&d[0]` à une fonction C qui s’attend à un tableau contigu.
- Invalidations d’itérateurs un peu plus compliquées, mais globalement, insertion au début/fin peut invalider certains itérateurs.

---

### 2.3. `std::list` – liste doublement chaînée

#### 2.3.1. Idée

- Chaque élément est dans un **maillon** (`node`) séparé, relié par pointeurs `prev` et `next`.
- Pas d’accès aléatoire : pas de `l[i]`.
- Très bonne pour :
  - insertion/suppression **en plein milieu**, **si on a déjà l’itérateur**.

#### 2.3.2. Complexité

- Insertion/suppression **à partir d’un itérateur donné** → **O(1)**.
- `push_back`, `push_front` → **O(1)**.
- Recherche par valeur (avec `std::find` par ex.) → **O(n)**.
- Accès à l’élément `i` → pas possible en O(1) (tu dois itérer → O(n)).

#### 2.3.3. Invalidations

- **Très stable** :
  - Insérer/supprimer dans une `list` n’invalide pas les itérateurs pointant vers les autres éléments.
- Seuls les itérateurs **vers les éléments supprimés** sont invalidés.

---

### 2.4. `std::forward_list` – liste simplement chaînée

- Pareil que `list` mais **simplement chaînée** (un seul `next`).
- Moins utilisée en général en C++, plus “C-like”.
- Pas d’itérateur bidirectionnel, seulement “avant”.

---

### 2.5. `std::array` et `std::string` (bonus)

#### `std::array<T, N>`

- Tableau **de taille fixe** connue à la compilation.
- Mémoire contiguë, comme `T tab[N];`, mais avec interface STL (`begin()`, `end()`, `size()`, etc).

```cpp
std::array<int, 3> a = {1,2,3};
```

#### `std::string`

- Séquence de `char`, dynamique.
- Très proche d’un `std::vector<char>` avec méthodes spécifiques (`substr`, `find`, etc.).

---

## 3. Conteneurs associatifs ordonnés : `set` / `map` & co

### 3.1. Implémentation conceptuelle

- En général : **arbres binaires de recherche équilibrés** (type red-black tree).
- Les éléments sont triés selon un comparateur (par défaut `<`).

### 3.2. `std::set` et `std::multiset`

- `std::set<T>` :
  - Ensemble **sans doublons**,
  - Les éléments sont triés.

```cpp
std::set<int> s = {3,1,4};
s.insert(2);     // s = {1,2,3,4}
s.insert(3);     // pas d'effet (3 déjà présent)
```

- `std::multiset<T>` :
  - Ensemble **avec doublons autorisés**.

```cpp
std::multiset<int> ms = {1,1,2};
ms.insert(1);    // {1,1,1,2}
```

#### Complexité

- `insert`, `erase`, `find` → **O(log n)**.

#### Propriétés importantes

- Les éléments sont **const** dans un `set` (tu ne peux pas modifier la clé directement via l’itérateur).
- Les itérateurs sont **bidirectionnels** (pas random access).
- Insertion/suppression ne casse pas tous les itérateurs (seuls ceux vers les éléments supprimés sont invalidés).

---

### 3.3. `std::map` et `std::multimap`

- `std::map<Key, T>` :
  - Associe une **clé** (`Key`) à une **valeur** (`T`),
  - Clés **uniques**,
  - Trié par clé.

```cpp
std::map<std::string, int> m;
m["Alice"] = 10;      // insère la clé "Alice" avec valeur 10
m["Bob"]   = 20;

int x = m["Alice"];   // x = 10
```

⚠ `operator[]` sur `map` :

- Retourne une **référence à la valeur associée** à la clé,
- Si la clé n’existe pas, elle est **créée avec valeur par défaut**.

```cpp
m["Charlie"];  // insère "Charlie" avec valeur 0 (si int)
```

→ Piège de DS : `map::operator[]` fait une **insertion implicite**.

- `std::multimap<Key, T>` :
  - Permet **plusieurs valeurs pour la même clé**.

#### Complexité

- `insert`, `erase`, `find` → **O(log n)**.
- `operator[]` de `map` → O(log n) aussi.

---

### 3.4. Parcours

Les `set` / `map` sont **triés** : l’itération suit l’ordre du comparateur.

```cpp
std::map<int, std::string> m;
m[2] = "deux";
m[1] = "un";
m[3] = "trois";

for (auto &p : m) {
    std::cout << p.first << " => " << p.second << '\n';
}
// Affiche : 1 => un ; 2 => deux ; 3 => trois
```

---

## 4. Conteneurs associatifs non ordonnés : `unordered_*`

### 4.1. Idée

- Basés sur des **hash tables**.
- Clés **non triées**, mais lookup très rapide en moyenne.

Conteneurs :

- `std::unordered_set`, `std::unordered_multiset`
- `std::unordered_map`, `std::unordered_multimap`

### 4.2. Complexité

- `insert`, `erase`, `find` :
  - **O(1) amorti**,  
  - **O(n)** dans le pire cas (collisions extrêmes).

### 4.3. Différences avec `set` / `map`

- Pas d’ordre :
  - L’itération se fait dans un ordre non déterministe.
- Utilise un **hash** :
  - Par défaut, pour les types de base (`int`, `std::string`, etc.), c’est géré.
  - Pour un type custom, tu dois fournir un `std::hash<T>` spécialisé ou un foncteur de hash.

Usage typique :

- Quand tu veux tester **présence/absence** (`set`/`map` de type “dictionnaire de lookup”),
- Et que tu n’as pas besoin d’ordre.

---

## 5. Adaptateurs : `stack`, `queue`, `priority_queue`

Ces types **n’ajoutent pas d’algorithmes**, ils **restreignent l’interface** d’un conteneur sous-jacent.

### 5.1. `std::stack<T>`

- Par défaut, basé sur `std::deque<T>`.
- Interface LIFO :
  - `push`, `pop`, `top`, `empty`, `size`.

```cpp
std::stack<int> st;
st.push(10);
st.push(20);
std::cout << st.top();  // 20
st.pop();               // enlève 20
```

### 5.2. `std::queue<T>`

- File FIFO.
- Par défaut, basé sur `std::deque`.

### 5.3. `std::priority_queue<T>`

- File de priorité (tas binaire).
- Par défaut, plus **grand** élément en premier.

---

## 6. Itérateurs : concepts, syntaxe, pièges

### 6.1. Qu’est-ce qu’un itérateur ?

- Objet qui se comporte comme un **pointeur généralisé** sur les éléments d’un conteneur :
  - `*it` → élément,
  - `++it` → passe au suivant,
  - pour random access : `it + n`, `it[n]`…

### 6.2. Catégories (important pour les algos)

1. **Input iterator** : simple lecture, unidirectionnel.
2. **Output iterator** : simple écriture, unidirectionnel.
3. **Forward iterator** : plusieurs passages en avant possibles.
4. **Bidirectional iterator** : `++it` et `--it`.
5. **Random access iterator** : toutes les opérations style tableau (`+`, `-`, `[]`).

Association typique :

| Conteneur       | Catégorie d’itérateur           |
|-----------------|----------------------------------|
| `vector`, `deque`, `array`, `string` | Random access       |
| `list`          | Bidirectional                   |
| `forward_list`  | Forward                         |
| `set`, `map`    | Bidirectional                   |
| `unordered_*`   | Forward                         |

Ça impacte les algos de `<algorithm>` que tu peux utiliser efficacement.

---

### 6.3. Syntaxes de base

```cpp
std::vector<int> v = {1,2,3};

for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}

for (auto it = v.cbegin(); it != v.cend(); ++it) {
    // it est un const_iterator : *it n'est pas modifiable
}
```

- `begin()` / `end()` :
  - `begin()` → itérateur sur le **premier élément**,
  - `end()` → itérateur **juste après le dernier** (ne pas déréférencer !).
- `cbegin()` / `cend()` :
  - itérateur **const** (lecture seule), même sur un conteneur non-const.

---

### 6.4. Invalidation des itérateurs (résumé DS ultra important)

| Conteneur     | Opération                       | Effet sur itérateurs                              |
|---------------|----------------------------------|---------------------------------------------------|
| `vector`      | réallocation (capacity change)  | **tous** invalidés                                |
|               | `insert`/`erase` au milieu      | itérateurs à partir de la modif invalidés         |
|               | `push_back` sans réalloc        | seul éventuellement `end()` change                |
| `deque`       | insert/erase au début/fin       | dépend, beaucoup peuvent être invalidés           |
| `list`        | insert/erase                    | seuls ceux vers les éléments effacés invalidés    |
| `set`/`map`   | insert/erase                    | seuls ceux vers éléments effacés invalidés        |
| `unordered_*` | réhash (changement de bucket)   | tous invalidés                                    |

---

## 7. Choisir le bon conteneur

### 7.1. Tableau de décision rapide

**Je veux :**

1. **Tableau dynamique, accès par index rapide, plutôt ajouter à la fin**  
   → `vector`

2. **Beaucoup de push_front + push_back, accès par index raisonnable**  
   → `deque`

3. **Beaucoup d’insert/erase au milieu, à partir d’itérateurs, sans besoin d’accès aléatoire**  
   → `list` (ou `forward_list` si mémoire très serrée / simple sens)

4. **Collection de valeurs sans doublons, triées**  
   → `set`

5. **Dictionnaire (clé → valeur) trié par clé, taille pas énorme, besoin d’itération en ordre**  
   → `map`

6. **Dictionnaire ou ensemble, surtout lookup rapide, ordre pas important, gros volume**  
   → `unordered_map` ou `unordered_set`

7. **Pile LIFO**  
   → `stack`

8. **File FIFO**  
   → `queue`

---

### 7.2. Exemples concrets

- **Liste de notes d’étudiants, triées par nom, accès par nom, souvent itérées dans l’ordre alphabétique**  
  → `std::map<std::string, int>`.

- **Liste de tâches que tu empiles/dépiles**  
  → `std::stack<Tache>` (ou `vector` avec convention, mais pour un DS, l’usage canonique c’est `stack`).

- **Set de “mots déjà vus” pour tester très souvent “est-ce que ce mot est déjà là ?”**  
  → `std::unordered_set<std::string>`.

- **Colonne de pixels à traiter en ordre, besoin de `push_front` + `push_back`**  
  → `std::deque<Pixel>`.

---

## 8. Pièges classiques de DS

### 8.1. `map::operator[]` insère si absent

```cpp
std::map<std::string, int> m;
std::cout << m["Alice"]; // insère "Alice" avec valeur 0 puis affiche 0
```

Essaie de **privilégier `find`** si tu veux tester la présence sans insertion :

```cpp
auto it = m.find("Alice");
if (it != m.end()) {
    // clé présente
}
```

---

### 8.2. Invalidation des itérateurs après `erase`

Ex :

```cpp
std::vector<int> v = {1,2,3,4,5};

for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0) {
        it = v.erase(it); // erase renvoie l'iter sur le suivant
    } else {
        ++it;
    }
}
```

- `erase` sur `vector` **retourne l’itérateur sur l’élément suivant**,
- et invalide l’itérateur initial + tous ceux après (car décalage).

Piège fréquent : faire `++it` après un `erase(it)` sans réaffecter → UB.

---

### 8.3. Confondre `vector<int> v(10);` et `vector<int> v; v.reserve(10);`

```cpp
std::vector<int> v(10);   // v a 10 éléments valides (tous = 0)
std::vector<int> u;
u.reserve(10);            // u n'a pas d'élément, capacity = 10, size = 0
```

- `reserve` ne crée pas d’éléments, il réserve de la **capacité**.

---

### 8.4. `set`/`map` : ne pas modifier la `clé` par un itérateur

Dans un `map<Key, T>`, la `Key` est prête à rester **const** dans l’élément :

```cpp
std::map<int, std::string> m;
m[1] = "un";

auto it = m.begin();
it->first = 2;   // Erreur : la clé est const
```

Sinon tu casserais la structure de l’arbre.

---

### 8.5. `std::remove` vs `erase` – “erase-remove idiom”

```cpp
std::vector<int> v = {1,2,3,2,4};

v.erase(std::remove(v.begin(), v.end(), 2), v.end());
```

- `std::remove` ne change pas la taille du vector !
  - Il "compacte" en déplaçant les éléments ≠ 2 au début,
  - Retourne un itérateur `new_end`,
  - Il reste des valeurs indéfinies logiques après `new_end`.
- Il faut appeler `erase` pour vraiment enlever du conteneur.

---

### 8.6. Différence entre `find` pour `set`/`map` et `std::find`

- `set`/`map` ont leur **propre `find` membre** → **O(log n)**.
- `std::find` (de `<algorithm>`) :
  - parcourt avec un itérateur → **O(n)**.

Toujours préférer `m.find(key)` à `std::find(m.begin(), m.end(), pair{...})`.

---

### 8.7. `auto` et type réel des itérateurs

Pour éviter d’écrire des horreurs comme :

```cpp
std::map<std::string, std::vector<int>>::iterator it;
```

On fait :

```cpp
auto it = m.begin();
```

Mais attention en DS : si le prof veut que tu **évalues le type exact**, tu dois savoir que :

- `m.begin()` sur un `map<Key, T>` → `std::map<Key, T>::iterator`,
- `v.begin()` sur un `vector<T>` → `std::vector<T>::iterator`,
- etc.

---

## Conclusion / Fiche express à relire juste avant le DS

- `vector` : tableau dynamique contigu, accès rapide par index, insertion fin rapide.
- `deque` : comme `vector` mais rapide aussi au début.
- `list` : liste chaînée, insert/erase O(1) avec itérateur, pas d’accès aléatoire.
- `set` : ensemble trié, sans doublon, find/insert/erase O(log n).
- `map` : dictionnaire trié, clé unique, `m[key]` insère si absent.
- `unordered_set`/`unordered_map` : hash table, lookup O(1) amorti.

Itérateurs :

- `begin()` / `end()` → [first, last+1)
- `cbegin()` / `cend()` → itérateur const
- invalidation : **savoir que `vector` et `unordered_*` sont les plus fragiles**.

`const` + pointeurs + références + STL :

- `const` s’applique à ce qui est à gauche,
- `const_iterator` = itérateur qui ne permet pas de modifier l’élément,
- `map::find` = O(log n), `unordered_map::find` = O(1) amorti.

---

[...retorn en rèire](../menu.md)