# Surcharge d’opérateur en C++  

[...retorn en rèire](../menu.md)

---

`+`, `-`, `=`, `<<`, `>>`, `ifstream` / `ofstream`, `endl`, etc.

> Objectif pour le DS :  
> - savoir écrire des surcharges **propres** pour `+`, `-`, `=`, `<<`, `>>` ;  
> - comprendre **quand** mettre l’opérateur **dans la classe** et **quand** en dehors ;  
> - être à l’aise avec `cout`, `cin`, `ifstream`, `ofstream`, `endl` et les **manipulateurs** ;  
> - savoir expliquer ce que fait le compilateur (chaining, conversions, associativité).

Je vais :

1. Poser les **principes généraux** sur la surcharge d’opérateurs  
2. Détail : `operator=` (assignation)  
3. Détail : `operator+` / `operator-`  
4. Détail : `operator<<` (sortie)  
5. Détail : `operator>>` (entrée)  
6. Tout le bordel `ostream` / `istream` / `ifstream` / `ofstream` / `endl`  
7. Mini-fiche de synthèse “spéciale DS”

Tout sera illustré avec des exemples simples (`Point`, `Vector2D`, etc.).

---

## 1. Principes généraux de surcharge

### 1.1. Quelques règles du langage

- On ne peut **pas** définir de nouveaux opérateurs, seulement surcharger ceux qui existent.
- Certains opérateurs **doivent** être des **méthodes membres** :
  - `operator=`, `operator[]`, `operator()`, `operator->`, `operator->*`,  
  - `operator++`, `operator--` (préfixe/postfixe) sont presque toujours membres.
- Les autres opérateurs binaires (`+`, `-`, `*`, `/`, `<<`, `>>`, `==`, `<`, etc.)  
  peuvent être définis **membres** ou **fonctions libres** (souvent `friend`).

**Important** : tu ne peux pas changer :
- la **priorité** (précédence) de l’opérateur,
- l’**associativité**,
- l’**arité** (unario/binaire).

Tu peux seulement changer **ce que fait l’opération** sur tes classes.

---

### 1.2. Style “propre” à viser

- **Const-correctness** :
  - opérateurs qui ne modifient pas l’objet → `const` :
    ```cpp
    Point operator+(const Point &other) const;
    ```
- **Passage par référence const** pour les gros objets :
  ```cpp
  Point operator+(const Point &lhs, const Point &rhs);
  ```
- Pour les opérateurs qui **modifient l’objet** (`=`, `+=`, `-=`, `>>` souvent) :
  - retourner une **référence sur *this*** pour permettre le chainage :
    ```cpp
    MyType& operator=(const MyType &rhs);
    MyType& operator+=(const MyType &rhs);
    std::istream& operator>>(std::istream &is, MyType &obj);
    std::ostream& operator<<(std::ostream &os, const MyType &obj);
    ```

---

## 2. `operator=` – l’assignation

### 2.1. Signature “canonique”

```cpp
class Vector {
public:
    // constructeur de copie
    Vector(const Vector &other);

    // opérateur d'assignation par copie
    Vector & operator=(const Vector &other) {
        if (this != &other) {
            // 1) libérer les ressources actuelles si nécessaire
            // 2) copier les données depuis other
        }
        return *this;  // toujours retourner *this
    }
};
```

Points clés :

- `operator=` **doit** être membre.
- Toujours retourner `*this` pour permettre :
  ```cpp
  a = b = c;   // interprété comme a = (b = c);
  ```
- Souvent, on vérifie `if (this != &other)` pour éviter de se copier soi-même bêtement.

### 2.2. Par défaut (si tu ne le définis pas)

Si tu n’écris pas `operator=`, le compilateur génère un opérateur d’assignation **membre à membre** (copie superficielle) :
- bon pour les types simples,
- dangereux si tu gères de la mémoire manuellement (`new/delete`).

En DS, on peut te demander :
- “Que fait l’operator= par défaut ?” → copie chaque sous-objet membre.

---

## 3. `operator+` et `operator-` – ops arithmétiques

On prend un exemple classique : un point 2D.

```cpp
class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    int getX() const { return x; }
    int getY() const { return y; }
};
```

### 3.1. Où définir `operator+` ? membre ou non-membre ?

#### Version membre :

```cpp
class Point {
    // ...
public:
    Point operator+(const Point &other) const {
        return Point(x + other.x, y + other.y);
    }
};
```

Utilisation :

```cpp
Point a(1, 2), b(3, 4);
Point c = a + b;   // OK
```

Mais si tu as des **conversions** possibles des deux côtés, l’approche **non-membre** est souvent meilleure.
Pour ton DS, ce qui est important : **savoir écrire les deux**.

#### Version fonction non-membre (`friend`)

```cpp
class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    friend Point operator+(const Point &lhs, const Point &rhs);
};

Point operator+(const Point &lhs, const Point &rhs) {
    return Point(lhs.x + rhs.x, lhs.y + rhs.y);
}
```

Même usage, mais :
- `operator+` n’appartient pas vraiment à la classe (`friend` donne juste l’accès privé),
- il est plus **symétrique** (`lhs` / `rhs`).

### 3.2. Relation `+=` et `+` (pattern propre)

Pattern ultra classique :

- tu implémentes **l’opérateur composé** (`+=`, `-=`) **en membre**,
- puis tu implémentes `+` / `-` en **termes de** `+=` / `-=`.

```cpp
class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    Point & operator+=(const Point &other) {
        x += other.x;
        y += other.y;
        return *this;
    }

    friend Point operator+(Point lhs, const Point &rhs) {
        lhs += rhs;       // réutilisation
        return lhs;       // renvoie une copie
    }
};
```

Explications :

- `operator+=` prend un `const Point&` et **modifie `*this`**, puis retourne `*this`.
- `operator+` prend `lhs` **par valeur** (copie), applique `+=`, puis renvoie la copie.
- Ce pattern est très **propre** et réutilise le code.

Idem pour `-` / `-=`.

---

## 4. `operator<<` – sortie (cout, ofstream, etc.)

### 4.1. Signature canonique pour un type perso

Pour un type `Point` :

```cpp
#include <iostream>

class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    int getX() const { return x; }
    int getY() const { return y; }

    // Déclaration friend
    friend std::ostream & operator<<(std::ostream &os, const Point &p);
};

// Définition
std::ostream & operator<<(std::ostream &os, const Point &p) {
    os << "(" << p.x << ", " << p.y << ")";
    return os;
}
```

Utilisation :

```cpp
Point p(1, 2);
std::cout << p << std::endl;     // OK

std::ofstream out("points.txt");
out << p << std::endl;           // OK aussi
```

### 4.2. Pourquoi **non-membre** (et `friend`) ?

- On veut pouvoir écrire `os << p` pour **n’importe quel flux** (`cout`, `ofstream`, `ostringstream`…).
- Le **premier argument** (`os`) est un `std::ostream&` → tu ne peux pas ajouter des méthodes directement à `std::ostream`.
- Donc on définit une **fonction libre** :

  ```cpp
  std::ostream & operator<<(std::ostream &os, const Point &p);
  ```

- `friend` permet d’accéder aux membres privés de `Point` (ici `x`, `y`).

### 4.3. Pourquoi on retourne `std::ostream&` ?

Pour pouvoir chaîner :

```cpp
std::cout << "p = " << p << std::endl;
```

S’interprète comme :

```cpp
operator<<( operator<<( operator<<(std::cout, "p = "), p), std::endl );
```

Chaque appel à `operator<<` renvoie une **référence au flux**, donc on peut enchaîner.

---

## 5. `operator>>` – entrée (cin, ifstream, etc.)

### 5.1. Signature canonique

Toujours la même idée : **non-membre**, souvent `friend` :

```cpp
class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    friend std::istream & operator>>(std::istream &is, Point &p);
};

std::istream & operator>>(std::istream &is, Point &p) {
    char ch;
    // Exemple : format "(x,y)"
    if (is >> ch && ch == '(' &&
        is >> p.x &&
        is >> ch && ch == ',' &&
        is >> p.y &&
        is >> ch && ch == ')') {
        // tout va bien
    } else {
        // mettre le flux en état d'erreur
        is.setstate(std::ios::failbit);
    }
    return is;
}
```

Utilisation :

```cpp
Point p;
std::cin >> p;        // lit depuis l'entrée standard

std::ifstream in("points.txt");
in >> p;              // lit depuis un fichier
```

### 5.2. Remarques importantes

- L’objet `p` est passé par **référence non const** (on le modifie).
- On retourne `std::istream&` pour permettre :

  ```cpp
  std::cin >> p1 >> p2;
  ```

  Interprété comme :

  ```cpp
  operator>>( operator>>(std::cin, p1), p2 );
  ```

- En cas de format incorrect, on marque le flux en **failbit** (comme font les opérateurs de base).

En DS on ne te demandera peut-être pas toute la gestion d’erreurs, mais au minimum :

```cpp
std::istream & operator>>(std::istream &is, Point &p) {
    return is >> p.x >> p.y;
}
```

C’est déjà acceptable.

---

## 6. Le “bordel” des flux : `ostream`, `istream`, `ifstream`, `ofstream`, `endl`, etc.

### 6.1. Hiérarchie simplifiée des flux

- `std::ostream` : flux de sortie générique (base de `std::cout`, `std::ofstream`, `std::ostringstream`).
- `std::istream` : flux d’entrée générique (base de `std::cin`, `std::ifstream`, `std::istringstream`).
- `std::ofstream` : dérive (directement ou indirectement) de `std::ostream`.
- `std::ifstream` : dérive de `std::istream`.

Ce qui est **crucial** pour toi :

> Un opérateur `operator<<(std::ostream&, const T&)` marche **pour `cout` mais aussi pour `ofstream`**, etc.  
> Parce que `ofstream` *est un* `ostream`.

Idem pour `operator>>(std::istream&, T&)` : marche pour `cin` et `ifstream`.

---

### 6.2. Pourquoi `std::endl` marche avec `cout << p << std::endl;`

`std::endl` est un **manipulateur** : une fonction à la con de type  

```cpp
std::ostream & endl(std::ostream & os);
```

Dans `<ostream>`, le standard définit une surcharge de `operator<<` pour les fonctions de ce type :

```cpp
std::ostream & operator<<(std::ostream & (*manip)(std::ostream &));
```

Donc :

```cpp
std::cout << std::endl;
```

= appelle en vrai :

```cpp
std::endl(std::cout);    // écrit '\n' et flush
```

Et :

```cpp
std::cout << p << std::endl;
```

=  

```cpp
operator<<( operator<<(std::cout, p), std::endl );
```

d’abord ton `operator<<(std::ostream&, const Point&)`,  
puis celui pour les manipulateurs (`std::endl`).

**À retenir pour le DS** :

- Ton `operator<<(std::ostream&, const T&)` ne doit **pas** s’occuper de `endl`.
- Tu te contentes de **retourner `os`**.
- Le reste (manipulateurs) est géré par les surcharges standard.

---

### 6.3. Composition avec les flux

Pattern très propre : faire une méthode `print` / `read` qui prend un `std::ostream&` / `std::istream&` :

```cpp
class Point {
    int x, y;
public:
    void print(std::ostream &os) const {
        os << "(" << x << ", " << y << ")";
    }

    void read(std::istream &is) {
        is >> x >> y;
    }

    friend std::ostream & operator<<(std::ostream &os, const Point &p) {
        p.print(os);
        return os;
    }

    friend std::istream & operator>>(std::istream &is, Point &p) {
        p.read(is);
        return is;
    }
};
```

Avantage :
- Tu peux réutiliser `print` / `read` ailleurs:

```cpp
void debugPoint(const Point &p) {
    p.print(std::cerr);
}
```

- Et ça marche **autant** pour `cout` que pour `ofstream`.

---

## 7. Récap : Quand opérateur membre / quand opérateur libre ?

### 7.1. Doivent être membres

- `operator=`  
- `operator[]`  
- `operator()`  
- `operator->`, `operator->*`  
- `operator++`, `operator--` (techniquement peuvent être libres, mais en pratique membres)  

Signature classique d’assignation :

```cpp
MyType & operator=(const MyType &rhs);
```

### 7.2. Souvent membres

- `operator+=`, `-=`, `*=`, `/=`, etc.
  - Ils modifient `*this`, donc logiques en membre :
    ```cpp
    MyType & operator+=(const MyType &rhs);
    ```

### 7.3. Souvent **non-membres** (fonction libre, parfois `friend`)

- `operator+`, `-`, `*`, `/`  
- `operator<<`, `operator>>`  
- opérateurs de comparaison `==`, `!=`, `<`, `<=`, `>`, `>=`

Exemple type (comparison) :

```cpp
class Point {
    int x, y;
public:
    friend bool operator==(const Point &a, const Point &b) {
        return a.x == b.x && a.y == b.y;
    }
};
```

Pourquoi les mettre **en dehors** ?

- Pour que la conversion puisse se faire sur **les deux opérandes** (gauche et droite).
- Pour rendre `a + b` plus symétrique.
- Pour ne pas polluer la classe avec trop de méthodes.

---

## 8. Un exemple “complet” à recoller en DS

Un petit type `Rational` pour résumer : `+`, `-`, `=`, `<<`, `>>`.

```cpp
#include <iostream>

class Rational {
    int num, den; // numérateur / dénominateur

    void normalize() {
        // simplifier la fraction, gérer les signes, etc.
        // (omise pour l'exemple)
    }

public:
    Rational(int n = 0, int d = 1) : num(n), den(d) {
        // on suppose d != 0
        normalize();
    }

    // operator= implicite généré par le compilateur suffit ici,
    // mais on peut l'écrire pour l'exemple :
    Rational & operator=(const Rational &other) {
        if (this != &other) {
            num = other.num;
            den = other.den;
        }
        return *this;
    }

    // += et -= en membre
    Rational & operator+=(const Rational &other) {
        num = num * other.den + other.num * den;
        den = den * other.den;
        normalize();
        return *this;
    }

    Rational & operator-=(const Rational &other) {
        num = num * other.den - other.num * den;
        den = den * other.den;
        normalize();
        return *this;
    }

    // + et - en non-membre
    friend Rational operator+(Rational lhs, const Rational &rhs) {
        lhs += rhs;
        return lhs;
    }

    friend Rational operator-(Rational lhs, const Rational &rhs) {
        lhs -= rhs;
        return lhs;
    }

    // opérateurs de flux
    friend std::ostream & operator<<(std::ostream &os, const Rational &r) {
        os << r.num << '/' << r.den;
        return os;
    }

    friend std::istream & operator>>(std::istream &is, Rational &r) {
        char slash;
        int n, d;
        if (is >> n >> slash >> d && slash == '/') {
            r.num = n;
            r.den = d;
            r.normalize();
        } else {
            is.setstate(std::ios::failbit);
        }
        return is;
    }
};
```

Utilisation :

```cpp
Rational a(1, 2), b(1, 3);
Rational c = a + b;       // operator+
a += b;                   // operator+=

std::cout << "a = " << a << ", b = " << b << ", c = " << c << std::endl;

std::ofstream out("data.txt");
out << c << std::endl;    // marche aussi, même operator<<
```

Tu peux quasiment recracher ça en DS en l’adaptant à la classe de l’énoncé.

---

## 9. Mini-fiche DS – à avoir en tête

### 9.1. Signatures à connaître

```cpp
// assignation
T & operator=(const T &rhs);

// arithmétique
T & operator+=(const T &rhs);        // membre
T & operator-=(const T &rhs);        // membre

friend T operator+(T lhs, const T &rhs);  // non-membre
friend T operator-(T lhs, const T &rhs);

// flux
friend std::ostream & operator<<(std::ostream &os, const T &obj);
friend std::istream & operator>>(std::istream &is, T &obj);
```

### 9.2. Idées à écrire si question de cours

- `operator<<` / `operator>>` sont **des fonctions libres**, généralement `friend`, car :
  - le premier paramètre doit être un `std::ostream&` / `std::istream&`,
  - on veut qu’ils fonctionnent pour **tous les flux** (`cout`, `ofstream`, `ostringstream`, etc.).
- Ils retournent une **référence au flux** pour permettre le **chainage** :
  ```cpp
  std::cout << a << b << std::endl;
  ```
- `std::endl` est un **manipulateur** (fonction `ostream&(ostream&)`) ; il y a une surcharge d’`operator<<` dans la STL qui sait l’appeler.
- `ifstream` dérive de `istream`, `ofstream` dérive de `ostream` :  
  les mêmes opérateurs `<<` / `>>` marchent avec fichiers **et** console.

---

[...retorn en rèire](../menu.md)