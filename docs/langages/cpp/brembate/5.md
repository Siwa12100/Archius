# Surcharge & Conversions de types en C++

[...retorn en rèire](../menu.md)

---

> Objectif :  
> - Comprendre **quand** et **comment** le compilateur convertit les types.  
> - Savoir ce que font **les constructeurs de conversion** et les `operator T()`.  
> - Comprendre le rôle de `explicit` et pourquoi sans ça, “tout part en couilles”.  
> - Être capable de **prédire** quelle surcharge est appelée, et pourquoi il y a parfois *ambiguïté*.

Je vais :

1. Poser les notions de base (surcharge vs conversion)  
2. Expliquer les **constructeurs de conversion**  
3. Expliquer les **opérateurs de conversion** (`operator T()`)  
4. Montrer ce que fait `explicit`  
5. Résumer le **processus de résolution de surcharge** avec conversions  
6. Montrer des **pièges classiques de DS**  
7. Donner des **patterns de design propres** à recopier

---

## 0. Surcharge vs conversion : les deux puzzles qui s’emboîtent

- **Surcharge** : plusieurs fonctions (ou opérateurs) avec **le même nom** mais **signatures différentes**.

  ```cpp
  void f(int);
  void f(double);
  void f(const std::string &);
  ```

- **Conversions** : pour appeler une fonction, le compilateur peut essayer de **convertir les arguments** vers les types attendus :
  - conversions standards (int → double, `T*` → `const T*`, etc.),
  - conversions utilisateur :
    - **constructeurs de conversion** (constructeurs à un seul argument),
    - **opérateurs de conversion** (`operator T()`).

La **résolution de surcharge** se fait en tenant compte des conversions possibles.
C’est là que ça devient “le bordel” : plusieurs surcharges + plusieurs conversions possibles → ambiguïtés.

---

## 1. Les conversions standards (rappel rapide)

Avant de parler de tes classes, faut savoir ce que le C++ fait tout seul.

### 1.1. Types de conversions standards

Exemples courants (simplifiés pour le DS) :

- **Aucune conversion** : types exactement égaux.
- **Promotion** :
  - `char`/`short` → `int`,
  - `float` → `double`,
- **Conversions numériques** :
  - `int` → `double`,  
  - `int` → `long long`,
- **Ajout de const / référence** :
  - `T` → `const T`,
  - `T` → `const T&`.

### 1.2. Règle d’ordonnancement (très simplifiée)

Pour choisir la meilleure fonction, le compilateur préfère :

1. Appels **sans conversion** (exact match),
2. Puis les **promotions**,
3. Puis les **autres conversions standards**,
4. Puis les **conversions utilisateur** (`ctor` de conversion / `operator T()`),
5. En dernier : `...` (ellipsis).

Donc, **une fonction qui ne demande pas de conversion** bat toujours une qui en demande une.

---

## 2. Constructeurs de conversion

### 2.1. Définition

Un **constructeur de conversion** est un constructeur qui peut être appelé avec **un seul argument** (les autres ayant des valeurs par défaut).

```cpp
struct Fraction {
    int num, den;

    Fraction(int n, int d = 1) : num(n), den(d) {}  // conversion int -> Fraction
};
```

Celui-là permet :

```cpp
Fraction f1(3);    // direct init : OK
Fraction f2 = 3;   // init par copie : OK (conversion implicite)
```

Ligne clé pour le DS :

- `Fraction f2 = 3;`  
  → conversion **implicite** `int → Fraction` via le constructeur.

### 2.2. Conversions implicites dans les appels de fonction

```cpp
void print(const Fraction &f);

print(5);   // OK : 5 est converti en Fraction(5)
```

Le compilateur voit :

1. `print(const Fraction&)` attend un `Fraction`.
2. Il voit un constructeur `Fraction(int)` → conversion utilisateur possible.
3. Il construit un `Fraction` temporaire à partir de `5` et l’envoie à `print`.

### 2.3. Danger : conversions implicites involontaires

Imagine :

```cpp
struct String {
    String(const char *s);
    // ...
};

void f(const String &s);

f("hello"); // OK : "hello" -> const char* -> String
```

Ici c’est voulu.  
Mais parfois, on ouvre la porte à des conversions absurdes :

```cpp
struct BoolLike {
    BoolLike(int x) {
        // ...
    }
};

void g(BoolLike b);

g(true);   // true -> int -> BoolLike, conversion implicite
g(0.5);    // 0.5 -> int (0) -> BoolLike(0)
```

Tu peux te retrouver avec des appels “magiques” qui ne sont pas du tout clairs.

---

## 3. Opérateurs de conversion (`operator T()`)

### 3.1. Définition

Un **opérateur de conversion** est une fonction-membre spéciale :

```cpp
struct Fraction {
    int num, den;

    operator double() const {    // conversion Fraction -> double
        return static_cast<double>(num) / den;
    }
};
```

Permet :

```cpp
Fraction f{3, 4};
double x = f;       // implicitement : x = f.operator double();
```

Et aussi :

```cpp
void h(double x);
h(f);               // Fraction -> double via operator double()
```

### 3.2. Danger : trop de conversions

Tu peux facilement créer des ambiguïtés :

```cpp
struct A {
    A(int) {}
    operator int() const { return 0; }
};

void f(int);
void f(A);

A a;
f(a);   // f(A) est meilleur (exact match) que f(int) via operator int()
```

Mais :

```cpp
void g(long);
void g(double);

A a;
g(a);   // a -> int -> long OU a -> int -> double : conversion utilisateur + standard
        // Ambigu possible selon le contexte
```

**Moralité** : éviter les `operator int()` / `operator double()` sur des types “non scalaires”.  
Ils font exploser la combinatoire de conversions.

---

## 4. `explicit` : mettre des barrières

### 4.1. `explicit` sur les constructeurs

```cpp
struct Fraction {
    int num, den;

    explicit Fraction(int n, int d = 1) : num(n), den(d) {}
};
```

Différences :

```cpp
Fraction a(3);      // OK (initialisation directe)
Fraction b = 3;     // ERREUR : constructeur explicit -> pas de conversion implicite

void f(Fraction);

f(3);               // ERREUR : conversion implicite interdite
f(Fraction(3));     // OK
```

**Règle d’or** :

- En général, les **constructeurs à un seul argument** doivent être `explicit`,  
  sauf si tu veux VRAIMENT une conversion implicite (cas exceptionnels).

### 4.2. `explicit` sur les opérateurs de conversion (C++11+)

```cpp
struct FileHandle {
    int fd;

    explicit operator bool() const {
        return fd != -1;
    }
};
```

Avec :

```cpp
FileHandle h{...};

if (h) {           // OK : contexte bool, autorise explicit operator bool
    // ...
}

bool b = h;        // ERREUR : pas de conversion implicite vers bool
bool c = static_cast<bool>(h);  // OK
```

Pour `bool`, c’est devenu la **bonne pratique** : `explicit operator bool()`  
(évite les conversions implicites vers `int`, etc.).

---

## 5. Ce que fait exactement `T x = a;` vs `T x(a);` vs `x = a;`

### 5.1. Initialisation

```cpp
T x1(a);   // initialisation directe
T x2 = a;  // initialisation par copie
```

Pour une **conversion de type** (un seul argument), en gros :

- Les deux appellent un **constructeur** compatible.
- Mais `explicit` bloque `T x2 = a;` si le constructeur est `explicit`.

Exemple :

```cpp
struct Fraction {
    explicit Fraction(int n, int d = 1);
};

Fraction a(3);   // OK
Fraction b = 3;  // ERREUR
```

### 5.2. Affectation : ce n’est PLUS un constructeur

```cpp
Fraction f(1);
f = 3;   // ici, on utilise operator=(const Fraction&),
         // et AVANT ça, 3 est converti en Fraction(3) via ctor de conversion
```

Donc `explicit` ici ?

```cpp
struct Fraction {
    explicit Fraction(int n, int d = 1);
};

Fraction f(1);
f = 3;   // ERREUR : conversion implicite int -> Fraction interdite
         // Il faut écrire :
f = Fraction(3);
```

**À retenir** :  
`explicit` affecte **toutes les conversions implicites** : construction, appels de fonctions, affectations…

---

## 6. Résolution de surcharge + conversions : comment le compilateur choisit

### 6.1. Étapes (version simplifiée DS)

Pour un appel `f(expr)` :

1. **Trouver les surcharges candidates** : toutes les fonctions `f` visibles.
2. **Filtrer les viables** : celles pour lesquelles on peut **convertir chaque argument** pour matcher la signature.
3. Pour chaque argument de chaque fonction viable, déterminer une **séquence de conversion**.
4. **Comparer** les fonctions viables : on garde la fonction dont **tous les arguments** ont des conversions “meilleures ou égales”, et au moins un strictement meilleure.
5. S’il y a plusieurs fonctions incomparables → **ambiguïté**.

### 6.2. Exemple simple avec types fondamentaux

```cpp
void f(int);
void f(double);

f(1);    // appelle f(int) : exact match, meilleur que conversion int->double
```

```cpp
void g(long);
void g(double);

g(1);    // dépend des détails, mais en général :
         // int -> long (promotion / conversion int->long)
         // est meilleur que int -> double si long peut contenir int sans perte
         // Le compilateur choisit alors g(long).
```

### 6.3. Exemple avec conversions utilisateur

```cpp
struct A {
    A(int) {}
};

struct B {
    B(int) {}
};

void h(A);
void h(B);

h(1);   // 1 -> A via A(int)
        // 1 -> B via B(int)
        // Les deux demandent "une conversion utilisateur"
        // Ambiguïté -> ERREUR
```

### 6.4. Cas “meilleure correspondance” pour les références

```cpp
void k(int &);
void k(const int &);

int x = 0;
k(x);      // k(int&) : match exact sur T& est meilleur que const T&
k(1);      // k(const int&) : impossible de lier un rvalue (1) à un int&, mais OK pour const int&
```

**Règle utile** :

- Les `T&` prennent les **lvalues non const**,
- Les `const T&` prennent tout (lvalues const, non const, rvalues),
- Mais `T&` est préféré quand c’est possible.

---

## 7. Gros mélange : surcharge d’opérateurs + conversions

### 7.1. Exemple “propre” de `operator+` pour une classe

```cpp
struct Fraction {
    int num, den;

    Fraction(int n, int d = 1) : num(n), den(d) {}

    // addition Fraction + Fraction
    friend Fraction operator+(const Fraction &a, const Fraction &b) {
        return Fraction(
            a.num * b.den + b.num * a.den,
            a.den * b.den
        );
    }
};
```

Avec le constructeur non `explicit`, on obtient :

```cpp
Fraction f(1, 2);
Fraction g = f + 1;     // 1 -> Fraction(1) implicite, OK
Fraction h = 1 + f;     // 1 -> Fraction(1) implicite, OK (opérateur non-membre)
```

Si tu marques le ctor `explicit` :

```cpp
explicit Fraction(int n, int d = 1);
```

Alors :

```cpp
Fraction f(1, 2);

Fraction g = f + 1;     // ERREUR : 1 ne peut pas être converti implicitement en Fraction
Fraction h = 1 + f;     // pareil
```

Tu DOIS écrire :

```cpp
Fraction g = f + Fraction(1);
```

Donc le choix de `explicit` dépend de si tu veux que `int` soit “quasi-éqivalent” à `Fraction` dans ton API.

---

## 8. Pièges classiques de DS / exam

### 8.1. Constructeur de copie vs constructeur de conversion

```cpp
struct X {
    X(const X &);   // constructeur de copie
    X(int);         // constructeur de conversion
};

void f(X);

X x(1);
f(x);    // utilise X(const X &)
f(2);    // utilise X(int)
```

On peut te demander : “Quel constructeur est appelé à chaque ligne ?”

### 8.2. Appel ambigu entre deux surcharges

```cpp
struct X {
    X(double) {}
};

void f(int);
void f(X);

f(1);    // Quel f ?

// 1 -> int       : exact match pour f(int)
// 1 -> X(double) : conversion utilisateur int -> double -> X
// f(int) est strictement meilleur -> f(int)
```

Maintenant :

```cpp
void g(X);
void g(double);

g(1);    // 1 -> double  : conversion standard
         // 1 -> X(double) : conversion utilisateur
         // g(double) est meilleur -> g(double)
```

### 8.3. Ambiguïtés avec plusieurs conversions utilisateur

```cpp
struct A {
    A(int) {}
};

struct B {
    B(double) {}
};

void h(A);
void h(B);

h(1);    // 1 -> A(int)  : conversion utilisateur
         // 1 -> B(double) : int -> double -> B(double) = user + standard
         // h(A) est meilleur (conversion plus simple)
```

Si tu changes :

```cpp
struct A {
    A(float) {}
};
struct B {
    B(double) {}
};

void h(A);
void h(B);

h(1);    // 1 -> float / double : les deux int -> float, int -> double => conversions standards
         // puis user-defined
         // ambigu possible selon le contexte
```

Typiquement, le sujet veut que tu expliques que le compilateur ne peut pas choisir → **erreur d’ambiguïté**.

---

## 9. Bonnes pratiques (à écrire dans une copie “conception”)

### 9.1. Toujours réfléchir aux conversions implicites

- Si ton type **représente une vraie valeur scalaire** (par ex. `Duration`, `Angle`) :  
  tu peux envisager une conversion implicite vers double, mais ça reste risqué.
- Si ton type est une **abstraction non triviale** (`Matrix`, `File`, `Socket`) :
  - **jamais** de `operator int()` / `operator double()` implicites,
  - éventuellement `explicit operator bool()` pour tester la validité.

### 9.2. Constructeurs à un seul argument : `explicit` par défaut

Écrire :

```cpp
class MyType {
public:
    explicit MyType(int x);
};
```

Et lever explicit **uniquement** si tu veux vraiment :

```cpp
void f(MyType);

f(3);              // autorisé uniquement si MyType(int) n'est PAS explicit
```

### 9.3. Éviter les `operator T()` multiples

Mauvaise idée :

```cpp
struct S {
    operator int() const;
    operator double() const;
};
```

Appel :

```cpp
void h(long);
void h(float);

S s;
h(s);   // s -> int -> long
        // s -> double -> float
        // Ambiguïté (deux conversions utilisateur + standard)
```

Solution :  
- Supprimer/désactiver les conversions douteuses,  
- Ou les marquer `explicit` + n’autoriser que `static_cast<T>(s)`.

---

## 10. Mini-fiche “recto DS”

À garder en tête le jour J :

- **Conversion implicite** = constructeur à 1 paramètre NON `explicit` ou `operator T()` non `explicit`.
- `explicit` :
  - bloque les conversions implicites,
  - n’autorise que :
    - l’initialisation directe (`T x(arg);`),
    - les cast explicites (`static_cast<T>(expr)`),
    - les contextes bool pour `explicit operator bool()`.

- **Ordre de préférence des conversions** (simplifié) :
  1. aucun changement de type (exact),
  2. promotions (`char`→`int`, `float`→`double`),
  3. autres conversions standards (`int`→`double`, etc.),
  4. conversions utilisateur (`ctor` / `operator T()`),
  5. `...`.

- En cas de deux surcharges :
  - Si l’une demande une conversion utilisateur et l’autre seulement une conversion standard → la seconde gagne.
  - Si les deux demandent une conversion utilisateur de même “qualité” → **ambigu**.

- **Pattern à réciter pour expliquer une erreur** :
  > Le compilateur considère les surcharges X et Y, trouve qu’elles sont toutes deux viables,  
  > mais aucune n’a une séquence de conversions strictement meilleure sur tous les paramètres,  
  > donc l’appel est ambigu et le code ne compile pas.

---

[...retorn en rèire](../menu.md)