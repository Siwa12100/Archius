# Cours  C++ – Instanciation, pile/tas, pointeurs, références, ctors/dtors, polymorphisme

[...retorn en rèire](../menu.md)

---

> Objectif : que tu puisses **lire n’importe quel bout de code du prof** et savoir :
> - *où* vit chaque objet (pile, tas, statique),
> - *quand* les constructeurs / destructeurs / copies sont appelés,
> - ce que font exactement pointeurs / références / const,
> - comment ça interagit avec le polymorphisme et `override`.

Je vais tout organiser en blocs, avec des exemples courts et des **résumés/pièges DS** à chaque fois.

---

## 1. Où vivent les objets ? (pile, tas, statique)

### 1.1. Trois grandes familles de durée de vie

1. **Automatique (souvent appelée “pile / stack”)**

   - Objets locaux dans une fonction, sans `static`, par exemple :
     ```cpp
     void f() {
         Point p(1,2);   // automatique
     }                   // destruction de p ici
     ```
   - Créés **quand on entre dans le bloc**, détruits **quand on en sort**.
   - Le destructeur est appelé automatiquement.

2. **Statique / globale**

   - Variables globales, ou locales avec mot-clé `static` :
     ```cpp
     Point g(1,2);      // globale

     void f() {
         static Point s(3,4);  // statique locale
     }
     ```
   - Créées **au lancement du programme** (ou au premier passage pour certains `static` locaux),
   - Détruites **à la fin du programme**.
   - Le destructeur est aussi appelé automatiquement (en fin de programme).

3. **Dynamique (tas / heap) – avec `new` / `delete`**

   - Créées explicitement avec `new`, détruites explicitement avec `delete` :
     ```cpp
     void f() {
         Point *p = new Point(1,2);  // allocation dynamique
         // ...
         delete p;                   // destruction manuelle
     }
     ```
   - Tant que tu ne fais pas `delete`, l’objet **reste vivant** (et tu fuites de la mémoire).

---

### 1.2. Résumé DS : qui détruira l’objet ?

| Type d’allocation              | Syntaxe typique               | Qui détruit ?                         |
|--------------------------------|-------------------------------|---------------------------------------|
| Automatique (pile)             | `Point p;`                    | Le C++ tout seul (fin de bloc)       |
| Statique / globale             | `Point g;` ou `static Point s;` | Le C++ tout seul (fin de programme)  |
| Dynamique (tas)                | `Point *p = new Point;`       | **Toi**, avec `delete p;`            |

---

## 2. Toutes les manières de “créer” un objet

Je vais d’abord parler de la **forme de la déclaration / initialisation**, *indépendamment* du fait que l’objet soit sur la pile ou sur le tas.

### 2.1. Sur la pile (automatique) : différentes formes

#### 2.1.1. Sans argument, sans `=`

```cpp
Point p;    // appel du constructeur par défaut Point()
```

- Appelle le **constructeur par défaut** (s’il existe).

#### 2.1.2. Initialisation directe

```cpp
Point p(1, 2);      // appel du constructeur Point(int, int)
```

- “Parenthèses après le nom de variable” ⇒ **initialisation directe**.

#### 2.1.3. Initialisation par copie

```cpp
Point p = Point(1, 2);  // (théoriquement) constructeur de copie
Point q = p;            // constructeur de copie
```

- Syntaxe avec `=` ⇒ **copy-initialization**.
- Appelle en principe le **constructeur de copie**.
- En pratique le compilateur peut optimiser (RVO), mais en DS on suppose qu’il l’appelle.

#### 2.1.4. Initialisation avec accolades `{}` (list-initialization)

```cpp
Point p{1, 2};   // compile en C++11+ si un ctor (int,int) existe
Point q{};       // appelle le constructeur par défaut
```

- Introduit pour uniformiser (et éviter certains piéges).
- Pour les types simples :
  ```cpp
  int x{};   // x = 0
  int y = int{}; // y = 0
  ```

#### 2.1.5. Attention au “most vexing parse”

```cpp
Point p(); // ATTENTION : déclaration d'une fonction p qui retourne un Point !
```

- Ce **n’est pas** la construction d’un objet,
- C’est la **déclaration** d’une fonction `p()`.

En DS, c’est un piège classique.

---

### 2.2. Sur le tas (`new`) : toutes les variantes

#### 2.2.1. Sans argument

```cpp
Point *p = new Point;     // constructeur par défaut
// ou équivalent à peu près
Point *p2 = new Point();  // value-initialization
```

- `new Point;` → **default-initialization**
  - Si `Point` a un constructeur par défaut, il est appelé.
- Pour les types simples :
  ```cpp
  int *pi1 = new int;    // valeur indéfinie !
  int *pi2 = new int();  // initialisé à 0
  ```

#### 2.2.2. Avec arguments (construction directe)

```cpp
Point *p = new Point(1, 2);  // appel direct du ctor (int,int)
```

#### 2.2.3. Avec accolades

```cpp
Point *p = new Point{1, 2};  // pareil que (1,2)
```

#### 2.2.4. Tableau dynamique

```cpp
Point *tab = new Point[10];   // 10 Points, tous construits par défaut
// ...
delete[] tab;                 // destructeur appelé 10 fois
```

- Ne jamais oublier le `[]` dans `delete[]`.

---

### 2.3. Résumé : formes de création

| But                            | Pile                              | Tas                                      |
|--------------------------------|-----------------------------------|------------------------------------------|
| par défaut                     | `Point p;` / `Point p{};`         | `new Point;`, `new Point();`, `new Point{}` |
| avec paramètres                | `Point p(1,2);` / `Point p{1,2};` | `new Point(1,2);` / `new Point{1,2};`   |
| par copie                      | `Point p = q;`                    | `new Point(q);` (constructeur copie)    |
| tableau                        | `Point tab[10];`                  | `new Point[10];` + `delete[]`           |

---

## 3. Constructeurs, copie, affectation, destructeurs

### 3.1. Types de constructeurs

Dans une classe typique :

```cpp
class Point {
public:
    Point();                        // constructeur par défaut
    Point(int x, int y);            // constructeur avec paramètres
    Point(const Point &p);          // constructeur de copie
    Point & operator=(const Point &p); // opérateur d'affectation
    ~Point();                       // destructeur
private:
    int x, y;
};
```

#### 3.1.1. Quand est appelé chaque constructeur ?

- **Constructeur par défaut** :
  - `Point p;`
  - `Point tab[10];` (10 fois)
  - `Point *p = new Point;`
  - `Point *tab = new Point[10];` (10 fois)

- **Constructeur avec paramètres** :
  - `Point p(1,2);`
  - `Point p{1,2};`
  - `Point *p = new Point(1,2);`

- **Constructeur de copie** :
  - `Point p = q;` (init par copie)
  - `Point r(q);`
  - Passage par valeur :
    ```cpp
    void f(Point p); // f(q); -> copie
    ```
  - Retour par valeur :
    ```cpp
    Point g();
    Point p = g(); // -> copie (en théorie)
    ```

### 3.2. Différence : constructeur de copie vs opérateur d’affectation

Très souvent confondus :

```cpp
Point a(1,2);
Point b = a;   // constructeur de copie (b naît ici)
b = a;         // opérateur d'affectation (b existait déjà)
```

- **Constructeur de copie** : crée un **nouvel objet** à partir d’un autre.
- **Affectation (`operator=`)** : modifie un objet **déjà existant** pour lui donner la valeur d’un autre.

Piège DS : vérifier si dans le code c’est une **déclaration** ou une **affectation**.

---

### 3.3. Destructeur : quand et combien de fois ?

Le destructeur `~Point()` est appelé :

- pour les objets **automatiques** (pile) : à la fin du bloc où ils sont déclarés,
- pour les objets **dynamique** : quand on fait `delete` (ou `delete[]`),
- pour les objets **statiques/globaux** : à la fin du programme.

Exemple :

```cpp
void f() {
    Point a(1,2);            // ctor
    Point *p = new Point(3,4); // ctor
}                            // dtor appelé pour a
                             // p est une fuite si pas delete

void g() {
    Point *p = new Point(5,6); // ctor
    delete p;                  // dtor
}                              // rien de plus (p est un pointeur, pas un objet Point)
```

Piège : `delete` appelle le destructeur **une seule fois**. Si tu fais :

```cpp
Point *p = new Point[10];
delete p;        // UB (comportement indéfini)
```

Tu appelles le destructeur **une fois** seulement, alors que tu as 10 objets → comportement indéfini.

---

### 3.4. Règle de 3 (version simplifiée)

Si tu écris **toi-même** :

- un destructeur,
- ou un constructeur de copie,
- ou un opérateur d’affectation,

alors tu devrais probablement écrire les 3 (souci de gestion de ressources : pointeurs internes, etc.).

---

## 4. Pointeurs et références (avec const)

C’est souvent là que tout explose en DS. On va aller très lentement.

### 4.1. Concept

- **Référence (`T&`)** :
  - Alias d’un objet existant,
  - Ne peut pas être “réassignée” pour référer un autre objet,
  - Doit être initialisée dès la déclaration,
  - En théorie, ne peut pas être nulle.

- **Pointeur (`T*`)** :
  - Contient une **adresse**,
  - Peut être `nullptr`,
  - Peut être réaffecté pour pointer autre chose,
  - Doit être **déréférencé** (`*p`) pour accéder à la valeur.

---

### 4.2. Références

```cpp
int x = 10;
int &r = x;   // r est un alias de x
r = 20;       // x vaut maintenant 20
```

**Avec const** :

```cpp
const int y = 30;
const int &cr = y; // référence constante : cr ne permet pas de modifier y

int z = 40;
const int &cr2 = z; // cr2 alias sur z, mais via cr2 on ne peut pas modifier z
```

Résumé :

- `T&` : on peut modifier l’objet (si lui-même n’est pas const).
- `const T&` : on ne peut pas modifier via cette référence (on peut lier à des temporaires).

---

### 4.3. Pointeurs

```cpp
int x = 10;
int *p = &x;   // p contient l'adresse de x
*p = 20;       // x vaut maintenant 20
```

**Pointeur nul** :

```cpp
int *p = nullptr;  // ne pointe vers rien
// *p -> UB (crash probable)
```

**Pointeur non initialisé** (piège énorme !) :

```cpp
int *p;    // contient une valeur indéterminée
*p = 10;   // comportement indéfini (peut tout casser)
```

---

### 4.4. Const + pointeurs : le tableau de vérité

On joue sur 2 idées :

1. **const sur ce vers quoi on pointe** (la valeur),
2. **const sur le pointeur lui-même** (l’adresse).

Notations équivalentes : `const T` == `T const`.

#### 4.4.1. Pointeur vers const

```cpp
const int *p;   // ou int const *p;
```

- On peut changer `p` (faire `p = &autrechose;`),
- On ne peut pas faire `*p = 42;` (interdit).

#### 4.4.2. Pointeur const vers non-const

```cpp
int * const p = &x;
```

- On **ne peut pas** changer l’adresse stockée dans `p` (p est “fixé” à &x),
- On **peut** modifier `*p` (donc `x`), si `x` n’est pas const.

#### 4.4.3. Pointeur const vers const

```cpp
const int * const p = &x; // ou int const * const p = &x;
```

- On ne peut ni changer l’adresse contenue dans `p`,
- ni modifier la valeur pointée via `*p`.

#### 4.4.4. Tableau récapitulatif

| Syntaxe                 | Peut modifier la valeur pointée ? | Peut changer l’adresse dans le pointeur ? |
|-------------------------|-----------------------------------|-------------------------------------------|
| `int *p`               | Oui                               | Oui                                       |
| `const int *p`         | Non                               | Oui                                       |
| `int * const p`        | Oui                               | Non                                       |
| `const int * const p`  | Non                               | Non                                       |

---

### 4.5. Pointeurs vs références sur des objets

```cpp
Point p(1,2);

Point *pp = &p;  // pointeur
Point &rp = p;   // référence
```

- Utilisation :

  ```cpp
  (*pp).M1();   // via pointeur (*p)
  pp->M1();     // notation flèche

  rp.M1();      // via référence (comme un objet normal)
  ```

- On peut **réassigner** un pointeur :

  ```cpp
  Point q(3,4);
  pp = &q;      // maintenant pp pointe q
  ```

- On **ne peut pas** réassigner une référence :

  ```cpp
  Point &rq = q;   // rq alias de q pour toujours
  ```

---

## 5. Passage de paramètres : valeur, référence, pointeur

### 5.1. Par valeur

```cpp
void f(Point p);   // COPIE de l'argument
```

- Appelle le **constructeur de copie**.
- Modifications internes à `f` ne touchent pas l’original.

### 5.2. Par référence

```cpp
void f(Point &p);        // référence
void g(const Point &p);  // référence constante
```

- **Pas de copie**.
- On travaille directement sur l’objet appelé :
  - `f(p1);` → f peut modifier `p1`.
  - `g(p1);` → g ne peut pas modifier `p1`.

### 5.3. Par pointeur

```cpp
void f(Point *p);        // pointeur
void g(const Point *p);  // pointeur sur const
```

- L’appelant passe une adresse (souvent `&obj`),
- On doit tester si `p != nullptr`,
- Très utilisé quand on veut signaler “absence d’objet” avec `nullptr`.

---

## 6. Polymorphisme, héritage, override, et lien avec pile/tas

### 6.1. Polymorphisme dynamique : conditions

Pour avoir **dynamique dispatch** (comportement selon le type réel), il faut :

1. Une **hiérarchie d’héritage** :
   ```cpp
   class Base { ... };
   class Derived : public Base { ... };
   ```

2. Au moins une méthode **virtuelle** dans la base :

   ```cpp
   class Base {
   public:
       virtual void f();
   };
   ```

3. Utiliser un **pointeur (ou une référence) de type Base** pointant/référençant un objet Derived :

   ```cpp
   Derived d;
   Base *pb = &d;
   Base &rb = d;

   pb->f();  // dynamique dispatch
   rb.f();   // dynamique dispatch
   ```

4. Optionnel : `override` dans la classe dérivée (fortement conseillé) :

   ```cpp
   class Derived : public Base {
   public:
       void f() override;  // surcharge de la version virtuelle
   };
   ```

### 6.2. Est-ce qu’il faut absolument `new` pour le polymorphisme ?

**Non.**

Polymorphisme fonctionne en pile comme en tas.

```cpp
void callF(Base &b) {
    b.f();     // polymorphique
}

int main() {
    Derived d;
    callF(d);  // OK : d est sur la pile
}
```

Pas besoin de `new`.

On utilise `new` quand :

- la durée de vie doit dépasser un scope,
- on veut gérer “à la main” la durée de vie (ou via smart pointer),
- ou parce qu’on stocke des pointeurs dans des conteneurs, etc.

---

### 6.3. Slicing (coupe/sciage) – piégeux

```cpp
Derived d;
Base b = d;   // attention !
```

- Ici, `b` est un **objet Base** construit **par copie** à partir de `d` :
  - La partie `Derived` est **perdue** (slicing).
  - Appeler `b.f()` n’utilisera que la version `Base::f` (sauf si f est virtual et que la copie conserve vtable, mais dans tous les cas l’objet **est de type Base**, pas Derived).
- Pour garder le polymorphisme, il faut utiliser une **référence** ou un **pointeur** :

  ```cpp
  Derived d;
  Base &rb = d;     // OK : pas de slicing
  Base *pb = &d;    // OK : pas de slicing
  ```

---

### 6.4. Destructeur virtuel (extrêmement important)

Cas ultra classique :

```cpp
class Base {
public:
    virtual void f();
    ~Base();            // PAS VIRTUEL (piège)
};

class Derived : public Base {
public:
    ~Derived();         // dtor
};

int main() {
    Base *p = new Derived();
    delete p;    // UB !
}
```

- Quand tu fais `delete p;`, c’est le type **statique** de `p` (Base*) qui compte pour **quel destructeur est appelé**.
- Si le destructeur de Base **n’est pas virtuel**, seul `~Base()` est appelé, **jamais** `~Derived()`.
- Résultat : la partie Derived n’est pas correctement détruite → comportement indéfini (fuites, etc.).

Solution : mettre un destructeur virtuel dans toute base polymorphe :

```cpp
class Base {
public:
    virtual ~Base() {}        // virtuel !
    virtual void f();
};
```

---

### 6.5. Résumé polymorphisme

- Polymorphisme dynamique = nécessite **virtual** + utilisation via **référence ou pointeur** sur base.
- `new` n’est **pas obligatoire** pour le polymorphisme, mais fréquent.
- Attention au **slicing** : `Base b = d;` (copie → partie Derived perdue).
- Pour `delete basePtr;` où basePtr pointe vers un Derived, base doit avoir un **destructeur virtuel**.

---

## 7. Synthèse des grands pièges en DS

### 7.1. Pointeurs non initialisés et pointeurs nuls

```cpp
Point *p;         // indéfini
p->M1();          // UB

Point *q = nullptr;
q->M1();          // UB aussi
```

Toujours initialiser les pointeurs, et vérifier avant utilisation si besoin.

---

### 7.2. Références et durée de vie

```cpp
Point &r = Point(1,2);  // référence sur un temporaire détruit à la fin de la ligne
```

- Après la ligne, `r` est une **référence pendante** (dangling reference) → UB.
- Exception : **const référence** peut prolonger la vie d’un temporaire :

  ```cpp
  const Point &r = Point(1,2); // temporaire prolonge sa durée de vie jusqu'à la fin du scope
  ```

---

### 7.3. Dangling pointer (pointeur pendu)

```cpp
Point *p;
{
    Point a(1,2);
    p = &a;
}   // destruction de a, p devient un pointeur pendu

p->M1();     // UB
```

---

### 7.4. Oublier `delete` ou mal utiliser `delete[]`

```cpp
Point *p = new Point;
delete[] p;    // UB

Point *tab = new Point[10];
delete tab;    // UB
```

Toujours :

- `new` ↔ `delete`
- `new[]` ↔ `delete[]`

---

### 7.5. Copies implicites (et coût)

```cpp
void f(Point p);   // copie
f(p1);
```

- Si `Point` est lourd (gros objet, ressources, etc.), préférer :

  ```cpp
  void f(const Point &p);
  ```

---

### 7.6. `Point p();` (most vexing parse)

```cpp
Point p();  // Déclare une fonction p qui retourne un Point et prend 0 paramètre
```

Pour construire un objet par défaut, il faut :

```cpp
Point p;    // ou Point p{};
```

---

## 8. Mini “cheat-sheet” final

### 8.1. Où est stocké l’objet ?

- `Point p;` → pile, destruction auto.
- `Point *p = new Point;` → tas, `delete p;` obligatoire.
- `static Point p;` ou global → statique, destruction fin de programme.

### 8.2. Quand y a-t-il copie ?

- `Point p = q;` → constructeur de copie.
- `Point p(q);` → constructeur de copie.
- `Point p = Point(1,2);` → (théoriquement) constructeur de copie.
- `void f(Point p); f(q);` → constructeur de copie.
- `Point g(); Point p = g();` → copie (ou RVO en pratique).

### 8.3. Polymorphisme

- Nécessite : `virtual` dans base + accès via `Base*` ou `Base&`.
- **Slicing** si tu passes par valeur (`Base b = d;`).
- Destructeur de base **virtuel** si tu delete via `Base*`.

### 8.4. Const + pointeurs / références

- `const T &` : pas de copie, pas modifiable via la ref.
- `T *` : pointeur “normal”.
- `const T *` : pointeur vers T const (on ne modifie pas la valeur via ce pointeur).
- `T * const` : pointeur constant (ne change pas d’adresse).
- `const T * const` : pointeur constant vers valeur constante.

---

[...retorn en rèire](../menu.md)