# Déclarations tordues, `const`, `static`, `inline`, `#define` 

[...retorn en rèire](../menu.md)

--- 

> Objectif : ne plus **jamais** paniquer devant un truc du genre  
> `const char * const * (*f[3])(int, char const *[])`  
> et ne plus se faire piéger par les `static`, `inline`, `#define`, `#ifdef` en DS.

Je vais structurer ça en 4 gros blocs :

1. Règles simples pour lire n’importe quelle déclaration C/C++  
2. `const`, pointeurs, tableaux, `char*` / `const char*` & co  
3. Déclarations “du démon” (pointeurs, tableaux, fonctions, pointeurs de fonctions)  
4. `static`, `inline`, `#define`, `#ifdef` & pièges classiques  

À la fin : une **cheat sheet synthèse** à relire avant DS.

---

## 1. Comment lire n’importe quelle déclaration C/C++ ?

### 1.1. Le principe général

En C/C++, une déclaration se lit en partant de :

- **l’identificateur** (le nom de la variable/fonction),
- puis on “tourne autour” en respectant les priorités `()`, `[]`, `*`,
- et on finit par le **type de base** à gauche.

Exemple simple :

```cpp
int *p;
```

- Base : `int`
- Vers le nom : `*p`
- On lit : **“p est un pointeur vers int”**

Exemple un poil plus complexe :

```cpp
int *p[10];
```

- Base : `int`
- À droite de `p` : `[10]`
- À gauche : `*`
- On lit dans l’ordre de priorité : `p[10]` puis `*` :  
  → “p est un **tableau de 10** éléments, chacun est un **pointeur vers int**”

**Règle d’or (version simplifiée)**  
1. On repère le **nom** (p, f, tab, etc.)  
2. On lit d’abord ce qu’il y a **autour du nom** en appliquant cette priorité :
   - `()` (appel / pointeur de fonction),
   - `[]` (tableau),
   - `*` (pointeur),
3. On termine par ce qu’il y a à gauche (type de base + `const`, etc.).

---

### 1.2. `const` : à quoi ça s’applique ?

Règle très importante :

> `const` s’applique à **ce qui est immédiatement à sa gauche**  
> (ou à sa droite si rien à gauche).

Exemples :

```cpp
const int x;   // const s'applique à int → int constant
int const y;   // pareil : int constant
int * const p; // const s'applique à *p → p est un pointeur constant vers int
const int * p; // const s'applique à int → pointeur vers int constant
```

On détaillera ça dans la section 2, mais garde **cette règle en tête** :  
const = “ce qu’il y a juste à gauche”.

---

## 2. `const`, pointeurs, `char*`, tableaux : tout démystifier

Tu vois souvent des trucs du genre :

- `const char *`
- `char const *`
- `char * const`
- `const char * const`
- `const char s[] = "abc";`
- `char *s = "abc";`

On clarifie TOUT.

---

### 2.1. Types simples

```cpp
const int a = 5;
int const b = 5;
```

→ exactement la même chose : `a` et `b` sont des **entiers constants**.

```cpp
int c = 5;
const int &r = c;   // référence constante vers c
```

- `r` ne permet pas de modifier `c` (via r),
- mais `c` lui-même reste modifiable directement.

---

### 2.2. Const + pointeurs (tableau récap rapide)

Les 4 cas standards :

```cpp
int *       p1;  // pointeur vers int
const int * p2;  // pointeur vers int constant
int * const p3 = &x; // pointeur constant vers int
const int * const p4 = &x; // pointeur constant vers int constant
```

Interprétation (avec la règle “const s’applique à ce qui est à gauche”) :

- `int *       p1;`  
  → `p1` : pointeur vers `int`  
  → on peut changer l’adresse stockée dans `p1` ET modifier `*p1`.

- `const int * p2;` == `int const * p2;`  
  → `p2` : pointeur vers **int constant**  
  → `*p2` ne peut pas être modifié via `p2`, mais `p2` peut pointer ailleurs.

- `int * const p3 = &x;`  
  → `const` s’applique au `*` → le **pointeur est constant**  
  → `p3` ne peut pas changer de valeur (ne peut pointer qu’un seul endroit),
  → mais on peut modifier `*p3`.

- `const int * const p4 = &x;`  
  → pointeur constant vers int constant  
  → ni l’adresse ni la valeur pointée ne sont modifiables.

Tableau mémo :

| Syntaxe                | Valeur pointée modifiable ? | Adresse modifiable ? |
|------------------------|-----------------------------|----------------------|
| `int *p`              | Oui                         | Oui                  |
| `const int *p`        | Non                         | Oui                  |
| `int * const p`       | Oui                         | Non                  |
| `const int * const p` | Non                         | Non                  |

---

### 2.3. `char*`, `const char*` et chaînes de caractères

Les chaînes de caractères littérales ( `"hello"` ) en C++ sont **const** (ou du moins doivent être traitées comme telles).

#### 2.3.1. Cas classiques

```cpp
char s1[] = "hello";
```

- `s1` est un **tableau modifiable** de `char` :  
  `{'h', 'e', 'l', 'l', 'o', '\0'}`  
- Tu peux faire : `s1[0] = 'H';`

```cpp
const char s2[] = "hello";
```

- `s2` est un **tableau constant** de `char`,
- Tu ne peux pas modifier `s2[i]`.

```cpp
const char *p1 = "hello";
```

- `p1` est un **pointeur** vers une zone en mémoire contenant `"hello"` (en principe en lecture seule),
- Tu peux faire `p1 = "world";` (changer ou ça pointe),
- Tu ne peux pas faire `p1[0] = 'H';` (UB).

```cpp
char *p2 = "hello"; // EN C++ : DÉCONSEILLÉ / POTENTIELLEMENT UB
```

- Littéral "hello" est stocké en mémoire non modifiable,
- `p2` est un pointeur vers `char` non-const → si tu modifies `*p2`, UB.

En DS, si tu vois `char *p = "truc";`, mentalement pense : **dangereux / UB**.

---

### 2.4. `const char[]`, `char const[]`, etc.

```cpp
const char s2[] = "hello";
char const s3[] = "hello";
```

- Identiques : `s2` et `s3` sont des **tableaux de caractères constants**.

---

### 2.5. `const` et références

Attention : **une référence est déjà un alias, elle ne peut pas elle-même être const au sens “réassignable”**.

```cpp
int x = 1, y = 2;
int &r = x;
r = y;  // modifie x, ne “réassigne” pas r
```

Essayer `int & const r2 = x;` est illégal : une référence ne peut pas être “const” de cette manière (c’est déjà non-réassignable par définition).

Le seul cas sensé :

```cpp
const int &r = x;  // référence constante vers int
```

- On **ne peut pas modifier** `x` via `r` (`r = 3` interdit),
- `x` lui-même reste modifiable.

---

## 3. Déclarations “du démon” : pointeurs, tableaux, fonctions

Tu vas voir des choses comme :

- `int *p[10];`
- `int (*p)[10];`
- `int *f(double);`
- `int (*f)(double);`
- `int (*f[3])(double, char *);`

On les démonte.

---

### 3.1. Outil mental : “commencer au nom, puis tourner”

Règle de lecture pratique :

1. Cherche le **nom** : `p`, `f`, etc.
2. Regarde ce qu’il y a **juste autour** de ce nom :
   - `()` avant `[]`,
   - puis `[]`,
   - puis `*`,
3. Ajoute le type de base à gauche à la fin.

---

### 3.2. Exemples standard

#### 3.2.1. `int *p[10];`

- On part du nom : `p`
- À droite : `[10]` → `p` est un tableau de 10 éléments.
- À gauche du nom : `*` → chaque élément est un pointeur.
- À gauche de tout : `int` → pointeur vers int.

→ `p` est **un tableau de 10 pointeurs vers int**.

#### 3.2.2. `int (*p)[10];`

- Nom : `p`
- Juste autour : `(*p)` (les parenthèses lient `*` au nom).
- À droite : `[10]` → `*p` est un tableau de 10 elements.
- À gauche : `int` → tableau de 10 int.

→ `p` est un **pointeur vers un tableau de 10 int**.

> Différence :  
> - `int *p[10];` → tableau de 10 pointeurs  
> - `int (*p)[10];` → pointeur vers tableau de 10 int

---

#### 3.2.3. Fonctions et pointeurs de fonction

```cpp
int f(double x);
```

→ `f` est **une fonction** qui prend un `double` et renvoie un `int`.

```cpp
int *f(double x);
```

→ `f` est une fonction qui prend un `double` et renvoie un **pointeur vers int**.

```cpp
int (*pf)(double);
```

- Nom : `pf`
- Autour : `(*pf)` → c’est quelque chose qu’on peut appeler (pointeur de fonction).
- À droite : `(double)` → accepte un `double`.
- À gauche : `int` → renvoie un int.

→ `pf` est un **pointeur vers une fonction** prenant un `double` et renvoyant `int`.

On peut faire :

```cpp
int f(double);
int (*pf)(double) = &f;  // ou = f;
int r = pf(3.14);        // appelle f(3.14)
```

---

#### 3.2.4. Tableau de pointeurs de fonctions

```cpp
int (*tab[3])(double);
```

- Nom : `tab`
- À droite : `[3]` → tableau de 3 éléments
- Autour du nom dans les parenthèses : `(*tab[3])` → chaque élément est un pointeur
- À droite de ça : `(double)` → chaque pointeur pointe vers une fonction prenant un double
- À gauche : `int` → renvoie un int

→ `tab` est **un tableau de 3 pointeurs de fonction** qui prennent un `double` et renvoient un `int`.

---

### 3.3. Ajouter du `const` là-dedans

Exemples :

```cpp
const char *tab[5];
```

- Tableau de 5 **pointeurs vers char constant**.

```cpp
char * const tab[5];
```

- Tableau de 5 **pointeurs constants vers char**.

```cpp
const char * const tab[5];
```

- Tableau de 5 **pointeurs constants vers char constant**.

Plus t’as de `*` et de `[]`, plus tu appliques la règle de lecture systématique.

---

### 3.4. Utiliser `typedef` / `using` pour simplifier (astuce DS)

Parfois, c’est trop chiant à lire. On peut factoriser :

```cpp
using Func = int(double);        // type "fonction prenant double retour int"
using PFunc = Func *;            // pointeur vers telle fonction

PFunc pf;        // plus lisible que int (*pf)(double);
PFunc tab[3];    // plus lisible que int (*tab[3])(double);
```

En DS, si le prof donne une déclaration très compliquée, essaye mentalement de la transformer via des typedefs pour **comprendre le type**, même si ce n’est pas écrit dans le code.

---

## 4. `static`, `inline`, `#define`, `#ifdef` – pièges classiques

### 4.1. `static` : 3 usages différents

1. `static` **variable locale** dans une fonction  
2. `static` **au niveau global/namespace** (C style)  
3. `static` **membre de classe** (attributs / méthodes statiques)

---

### 4.1.1. `static` local dans une fonction

```cpp
void f() {
    static int c = 0;
    c++;
    cout << c << endl;
}
```

- `c` est **créée une seule fois** (durée de vie = tout le programme),
- mais **visible uniquement dans f**,
- à chaque appel de `f`, `c` conserve sa valeur précédente.

Comparaison :

```cpp
void g() {
    int c = 0;
    c++;
    cout << c << endl;
}
```

→ `c` est recréée à chaque appel, toujours 1.

Piège DS : demander la trace de plusieurs appels à une fonction avec `static`.

---

### 4.1.2. `static` au niveau global (C-style)

```cpp
// fichier A.cpp
static int x = 0;
static void helper() { ... }
```

- `x` et `helper` ont une **liaison interne** (internal linkage) :
  - visibles **uniquement** dans `A.cpp`,
  - pas accessibles depuis d’autres `.cpp`.

Sans `static` :

```cpp
int y = 0;
void helper2() { ... }
```

- `y` et `helper2` ont une **liaison externe** (external linkage),
- accessibles via `extern` depuis d’autres fichiers.

---

### 4.1.3. `static` dans une classe

```cpp
class Point {
public:
    static int compteur;
    static void printCompteur();
};
```

- `static int compteur;` → **une seule variable** partagée entre tous les `Point`,
- `static void printCompteur();` → méthode qui n’a pas de `this`,
  - s’appelle via `Point::printCompteur();`
  - ne peut accéder qu’aux membres statiques de la classe.

Il faut en général **définir** la variable statique dans un `.cpp` :

```cpp
int Point::compteur = 0;
```

Piège : oubli → “multiple definition” ou “undefined reference” à l’édition des liens.

---

### 4.2. `inline`

Historiquement :

- `inline` signale au compilateur que la fonction peut avoir **plusieurs définitions** (par ex. dans un header) sans violer la règle de l’ODR,
- et **peut** (optionnellement) être insérée “in-line” (pas d’appel de fonction), mais c’est une optimisation, pas une garantie.

Pourquoi `inline` dans un header ?

```cpp
// Point.h
inline int add(int a, int b) {
    return a + b;
}
```

- `inline` permet de mettre la définition dans le header sans causer “multiple definitions” si le header est inclus dans plusieurs `.cpp`.

Ne pas confondre avec `#define` :

```cpp
#define ADD(a,b) ((a)+(b))
```

- Pas de type,
- Problèmes de parenthèses, effets de bord, etc.

`inline` est **type-safe** et obéit aux règles du langage (portée, surcharge, etc).

---

### 4.3. `#define`, macros, `#ifdef`, include guards

#### 4.3.1. Macros constantes

```cpp
#define TAILLE 10

int tab[TAILLE];
```

- Remplacement texte brut **avant** compilation.

Beaucoup mieux en C++ moderne :

```cpp
const int TAILLE = 10;
```

ou

```cpp
constexpr int TAILLE = 10;
```

→ type, portée, pas de surprise de préprocesseur.

#### 4.3.2. Macros fonctions

```cpp
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

Pièges :

- Si tu oublies les parenthèses général autour `(a)` `(b)` tu as des surprises,
- Si `a` a un effet de bord (ex. `i++`), ça peut être évalué plusieurs fois.

Ex :

```cpp
MAX(i++, j)   // i++ peut être évalué 2 fois !
```

Version sûre C++ :

```cpp
template <typename T>
T max(T a, T b) { return a > b ? a : b; }
```

---

#### 4.3.3. Include guards

Pour éviter de définir une classe/macro plusieurs fois :

```cpp
#ifndef POINT_H
#define POINT_H

class Point { ... };

#endif
```

Sans ces garde-fous (`#ifndef` / `#define` / `#endif`) :

- Tu peux avoir **des doubles définitions** si le header est inclus plusieurs fois directement ou indirectement.

---

#### 4.3.4. `#ifdef`, `#ifndef`, `#if`

Très utilisé pour :

- Compilation conditionnelle (comme ton `#ifdef MAP` dans le TD),
- Activer/désactiver des parties du code (debug vs release).

```cpp
#define MAP

#ifdef MAP
cout << ">> debug" << endl;
#endif
```

Si `MAP` est défini (dans le code, ou avec `-DMAP` au compilateur), le bloc sera compilé. Sinon il sera ignoré.

Piège DS :

- Le prof peut demander la **sortie exacte** d’un programme en te disant “on suppose que `MAP` est défini”,
- Ou au contraire “MAP n’est pas défini” → toutes les lignes sous `#ifdef MAP` sont **complètement absentes** du binaire.

---

### 4.4. Résumé des pièges liés à `static`, `inline`, `#define`

- `static` local → **durée de vie globale**, valeur conservée entre appels.
- `static` global/namespace → **visibilité limitée au fichier**.
- `static` membre de classe → **partagé** par tous les objets, une seule instance → nécessite une définition dans un `.cpp`.
- `inline` permet de **définir dans un header** sans problème de multiple definition (fonction / variable inline).
- `#define` fait du **remplacement texte brut** → attention TIPE, effets de bord.
- `#ifdef` / `#ifndef` contrôlent ce qui est compilé, pas ce qui est exécuté.

---

## 5. Cheat sheet final pour le DS

### 5.1. `const` + pointeurs

- `const` s’applique à **ce qui est à sa gauche**, ou à sa droite si rien à gauche.
- `const int *p` → pointeur vers int constant → `*p` non modifiable, `p` oui.
- `int * const p` → pointeur constant vers int → `*p` modifiable, `p` non.
- `const int * const p` → pointeur constant vers int constant.

### 5.2. Chaînes de caractères

- `char s[] = "abc";` → tableau modifiable de char.
- `const char s[] = "abc";` → tableau *non* modifiable.
- `const char *p = "abc";` → pointeur vers char constant (classique).
- `char *p = "abc";` → **dangereux** : littéral en lecture seule.

### 5.3. Déclarations complexes

- **Lecture** : partir du nom, puis `()`, `[]`, `*` en priorité, terminer avec type de base.
- `int *p[10];` → tableau de 10 pointeurs vers int.
- `int (*p)[10];` → pointeur vers tableau de 10 int.
- `int (*f)(double);` → pointeur vers fonction prenant double, renvoyant int.
- `int (*f[3])(double);` → tableau de 3 pointeurs vers fonctions (double→int).

### 5.4. `static`

- Local `static` → persiste tous les appels, visible que dans la fonction.
- Global avec `static` → visible uniquement dans le `.cpp` courant.
- `static` dans une classe :
  - attribut : partagé par tous les objets → 1 seule instance,
  - méthode : pas de `this`, s’appelle via `Class::method`.

### 5.5. `inline` vs `#define`

- `inline` :
  - fonction/var normale du langage,
  - type-safe,
  - permet plusieurs définitions identiques dans différents `.cpp` (via header).
- `#define` :
  - simple remplacement texte,
  - aucun type, aucun contrôle,
  - pièges de parenthèses et effets de bord.

---

[...retorn en rèire](../menu.md)